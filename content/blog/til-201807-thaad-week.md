+++
author = "@yu-kgr"
categories = ["TIL"]
date = "2018-07-20"
description = "2018/07 - thaad week I Learned | 一週間で知った事・学んだ事の個人的な備忘録"
featured = "/img/til/til.jpg"
featuredalt = "til"
featuredpath = "https://kglabo.com"
title = "2018/07 - thaad week I Learned"
type = "post"
draft = "false"
+++

# 今週、知った/学んだこと

- 数日間、海外に行っていたので抜けておりまする。

<!-- tags = ["Linux Command"] -->

## 2018/07/19 - Learned

7月19日（木）のToday I Leaned.

### tail/head Command

- ファイルの内容を部分的に閲覧する事が可能。
  - 「tail（尾）」がファイルの末尾10行（default）だけを表示する
  - 「head(頭)」がファイルの先頭10行（default）だけを表示する
- （tailは前にも書いたけど復習もこめて）
 
#### head Command

- `head {オプション} {ファイル名}`の形で実行。
- `head -n {行数} {ファイル名}` で 取得・表示する行数を指定する事が可能。
  - 他に -c / -q / -v などのオプションも存在するが使い所はあんまりわからなかった。
- `{他のコマンド} | head` とかみたいにパイプでつないでコマンド実行時の最初のログだけ確認したい時などに使える模様。

#### tail Command
  
- `tail {オプション} {ファイル名}`の形で実行。
- こちらも同じく、 `tail -n {行数} {ファイル名}` で取得する行数を指定する事が可能。
  - head同様に、 -c / -q / -v などのオプションが存在するがry
  - tailだけ `-f`/ `-F`などのファイルを監視して変更があったら追加表示していくオプションが存在する。
  - 違いとしては、監視するファイル名が変更された際に再度オープンするのが `-F`で、そのまま開き続けるのが `-f`。基本的に`-F`で良い気がする。
  

### wc Command

- word countの略。テキストファイルの行数や単語数をカウント。`wc {オプション} {ファイル名}` で記載する。
- 単語数とか行数とかバイト数を取得するときに使う
- オプションの種類は…
  - `-c （--bytes）` / バイト数を表示する
  - `-m（--chars）` / 文字数を表示する（マルチバイト文字に対応）
  - `-l（--lines）` / 改行の数を表示する
  - `-w（--words）` / 単語数を表示する
  - `-L（--max-line-length）` / 最も長い行の長さを表示する
- 若干オプション名が覚えづらい感ある。

### grep Command

- Global Regular Expression Print（グローバル正規表現の表示）の略らしい。`grep {検索したい文字列} {検索したいテキストファイル}`で検索する事が可能。
- [参考:grepってなあに？](https://qiita.com/kamorits/items/db814666a133fb9ae892)

## 2018/07/20 - Learned

7月20日（金）のToday I Leaned.

### 正規表現

- `/{検索ワード}/g`で膨大なデータの中から指定文字を検索する事が可能。基本的には「文字列」と「メタ文字」の組み合わせである。
- [参考:運用型広告の運用者がおさえておきたい正規表現、基本の「き」](https://anagrams.jp/blog/basic-of-regular-expression-for-ppc-account-manager/)
- 尚、全部[regexr.com](https://regexr.com/)で試してみた。

#### 一文字にマッチング

- `\d` - 0~9の数字 / `[0-9]に相当`
  - 活用例としては、 `\d+`とか `\d*`とか `\d?`とか
- `\D` - 数字以外の文字 / `[^0-9]`に相当
- `\s` - 空白文字・タブ・改行
- `\S` - 空白文字・タブ・改行 以外の文字
- `\w` - アルファベット・数字・アンダースコア / `[A-Za-z0-9]`に相当
  - 活用例としては、 `\w+`とか `\w*`とか `\w?`とか
- `\W` - アルファベット・数字・アンダースコア 以外 / `[^A-Za-z0-9]`に相当

#### メタ文字
- `.` - 任意の一文字
  - `/AKB4./g`とすると、AKB4の次の1文字に何かが入った単語を検索してくれる。
  - `/ALB../g`とすると、AKBの次の2文字に何かが入った単語を検索してくれる。
  - `.`自体を検索したい場合は、`\.`という形でエスケープする必要がある。
- `[]`内のいずれかの文字
  - `[bc]at`とした場合、 `bat`,`cat` でマッチする
  - `[^bc]at`とした場合は、指定した複数の文字のどれか1文字とマッチさせたくない場合なので、 `aat`, `dat`でマッチする
  - 文字の範囲指定も可能
    - `[0-9]`で、0から9まで / `\d`に相当
    - `[a-z]`で、aからz（小文字） / 
    - `[A-Z]`で、AからZまで（大文字）
    - `[a-zA-Z]`で、aからz & AからZまで
    - `[0-9a-zA-Z]`で、0から9、aからz、AからZまで / `\w`に相当
- `?` - 0回か1回の繰り返し / 直前の文字が全く無い or 1つだけ存在する場合にマッチ
- `+` - 1回以上の繰り返し / 直前の文字が1個以上連続するものにマッチ
- `*` - 0回以上の繰り返し / 直前の文字が無い or 直前の文字が1個以上連続するものにマッチする
- `{m,n}` - 最小m回で最大n回
- `^` - 文字列の先頭
  - `^hoge` - 行頭から始まるhogeという単語を検索する
- `$` - 文字列の末尾
  - `hoge$` - 行末からhogeという単語を検索する
- `|` - いづれかにマッチさせたい場合
  - `cat|dog|bird` - `cat`, `dog`, `bird`のいづれか単語にマッチする
- `()` - `()`で囲む事でグルーピングする事ができる。下記のような感じで利用
  - `/item/(cat|dog|bird)` - `/item/`以降に`cat`または`dog`または`bird`がある場合にマッチ
  - `/(item/)*cat/` - `item/`が存在しないか存在する。かつ、`cat`がある場合にマッチ
- `{n}` - 直前の文字列がn個連続である場合にマッチ 
  - `(ca){2}`の場合は、cacaaという単語の`caca`にマッチ
  - `ca{2}`の場合は、cacaaという単語の`caa`にマッチ 


### React

#### 設計時に考える事

- Componentの分割とStateを誰に持たせるのかを事前に考えるたほうが良い。

1. 何をしたら、どういった事が実現されるのかを決める
2. 実現する為にどんなコンポーネントがいるのかを考える
  - 大枠としてappコンポーネントがあり、その中に内包されるコンポーネントを考える
3. それぞれのコンポーネントに対して、どのような情報（ステート）が必要なのかを考える
4. コンポーネントから、情報（ステート）がどういう形で渡されていくのかを考える
