<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TIL on kglabo.com</title>
    <link>https://kglabo.com/categories/til/</link>
    <description>Recent content in TIL on kglabo.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 03 Aug 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kglabo.com/categories/til/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2018/08 - one week I Learned</title>
      <link>https://kglabo.com/blog/til-201808-one-week/</link>
      <pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201808-one-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [&#34;&#34;] --&gt;

&lt;h2 id=&#34;2018-07-30-learned&#34;&gt;2018/07/30- Learned&lt;/h2&gt;

&lt;p&gt;7月30日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;eslint&#34;&gt;ESLint&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;拡張子無しの.eslintrcはJSON,YAMLで記述可能ですが現在は非推奨です&lt;/li&gt;
&lt;li&gt;こんな感じのエラーを出してくれる

&lt;ul&gt;
&lt;li&gt;Unexpected block statement surrounding arrow body (arrow-body-style)&lt;/li&gt;
&lt;li&gt;関数がreturn分しか含まない場合は、ブレース（&lt;code&gt;{}&lt;/code&gt;）とretun文とセミコロンを省略できる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;() =&amp;gt; {
  return 1;
}

// 省略したケース
() =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2018-07-31-learned&#34;&gt;2018/07/31- Learned&lt;/h2&gt;

&lt;p&gt;7月31日（火）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;javascript-1&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;ループ処理&#34;&gt;ループ処理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;こういうのは古いらしい&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# 古いコード
var iterable = [10, 20, 30];

for (var i = 0; i &amp;lt; iterable.length; i++) {
  var value = iterable[i];
  console.log(value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ループを回して、要素をひとつずつ取り出す・・・というコードは &lt;code&gt;for ... of&lt;/code&gt;を使う。

&lt;ul&gt;
&lt;li&gt;イテレータプロトコル（反復処理プロトコル）というらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# ナウいコード
const iterable = [10, 20, 30];

for (const value of iterable) {
  console.log(value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;flow&#34;&gt;Flow&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Facebook制の静的型チェッカー&lt;/li&gt;
&lt;li&gt;rootで&lt;code&gt;flow init&lt;/code&gt;で利用可能&lt;/li&gt;
&lt;li&gt;動作させたいファイルの先頭に &lt;code&gt;// @flow&lt;/code&gt;とか&lt;code&gt;/* @flow */&lt;/code&gt;とかいれると動作する&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;jest&#34;&gt;Jest&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;FacebookによるJavaScriptテストライブラリ / &lt;a href=&#34;https://jestjs.io/ja/&#34;&gt;Jest/快適なJavaScriptのテスト&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;他にもjasmine, mocha+chaiとか色々あったらしいが、これから触るマンとしてはよく知らん。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1パッケージいれるだけで「テストランナー/アサーション/モック/カバレッジ」の機能が利用可能&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/karak/items/9d0ebf7bc50085624913&#34;&gt;参考:ついに jest の軍門に降った&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__tests__&lt;/code&gt;ディレクトリ作ってその中にファイルを入れるか、 &lt;code&gt;.spec.js&lt;/code&gt;または&lt;code&gt;.test.js&lt;/code&gt;をつけると勝手にファイル見つけて実行してくれる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-08-01-learned&#34;&gt;2018/08/01- Learned&lt;/h2&gt;

&lt;p&gt;8月1日（水）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;javascript-2&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;express&#34;&gt;Express&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Nodeを利用したWebApplicationFramework。割とシンプルかつ最小限のAPIを提供するとの事&lt;/li&gt;
&lt;li&gt;&lt;code&gt;express-generator&lt;/code&gt; とか使うとてっとり早くスケルトンを作成可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;nodemon&#34;&gt;Nodemon&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ディレクトリ内でファイルの変更が発生したら、ノードサーバーを自動的に再起動するユーティリティ。&lt;/li&gt;
&lt;li&gt;Node.jsで開発するとき、ソース修正後、手動でnode.jsプロセスを再起動しないと反映されないという問題がある。

&lt;ul&gt;
&lt;li&gt;Node.jsで読み込まれたJavascriptファイルがキャッシュされるため、ソースコードを更新しても、Node.jsの再起動をしないとソースが反映されない為。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pm2&#34;&gt;pm2&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Node Process Manager 2 の略らしい&lt;/li&gt;
&lt;li&gt;Nodeプログラムを常時デーモンで稼働させる際に利用したりする。&lt;/li&gt;
&lt;li&gt;具体的には常時起動させつつ、こんな事させたり

&lt;ul&gt;
&lt;li&gt;アプリケーションが異常終了した場合に自動的に再始動する。&lt;/li&gt;
&lt;li&gt;ランタイム・パフォーマンスとリソース使用量に関するインサイトを得る。&lt;/li&gt;
&lt;li&gt;パフォーマンスを向上させるために設定を動的に変更する。&lt;/li&gt;
&lt;li&gt;クラスタリングを制御する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;今週の詰まった所&#34;&gt;今週の詰まった所&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;フロントエンド環境、どれが最新情報なのかわからない問題

&lt;ul&gt;
&lt;li&gt;基本的に日本語で説明されている内容が古い事が多い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;やたら書き方が変わる.babelrc&lt;/li&gt;
&lt;li&gt;ぶっちゃけ覚えなくていいprototype（黙ってES2015のクラス宣言覚えとけばOK&lt;/li&gt;
&lt;li&gt;jestを導入したら依存ライブラリ周りでエラーが出る

&lt;ul&gt;
&lt;li&gt;1に関係する内容だけど、モジュールが独自の進化を遂げてるケースがあるのでissueとか見に行く必要がある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Editer自体のユーザ設定に「この設定がおすすめやで！」みたいなのを脳停止で入れると後々ボディブローしてくる&lt;/li&gt;
&lt;li&gt;flowで依存ライブラリがRequired module not found返して来るので、flow-typedで定義済みの型ファイルを使おうとしたら、ちょいちょいなくて自分で型定義ファイルを書けと言われる。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>2018/07 - four week I Learned</title>
      <link>https://kglabo.com/blog/til-201807-four-week/</link>
      <pubDate>Mon, 23 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201807-four-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [&#34;PullRequest&#34;, &#34;React&#34;, &#34;JavaScript&#34;] --&gt;

&lt;h2 id=&#34;2018-07-23-learned&#34;&gt;2018/07/23 - Learned&lt;/h2&gt;

&lt;p&gt;7月23日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;githubのprについて&#34;&gt;GithubのPRについて&lt;/h3&gt;

&lt;p&gt;GithubのPRについてあんまり理解していなかったので、改めて備忘録。&lt;br /&gt;
&lt;a href=&#34;https://qiita.com/terra_yucco/items/fa08bd2a4b498963a313&#34;&gt;参考:GitHubのReview機能が強化された&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kglabo.com/img/2018/07/github-pr-1.png&#34; alt=&#34;githubのPRに対しての総評Review&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PR自体に &lt;code&gt;Review changes&lt;/code&gt; より総評のような形でReviewを記載する事ができる

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Comment&lt;/code&gt; / PRに対して承認などはせず、コメントのみを記載する際に利用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Approve&lt;/code&gt; / PRに対して承認する事ができる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Request changes&lt;/code&gt; / PRに対して修正依頼を出すことができる。（これを修正しないとマージする事ができない）&lt;/li&gt;
&lt;li&gt;感覚的には「Comment（見たよ）」「Approve（イイね）」「Request changes（ダメ）」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://kglabo.com/img/2018/07/github-pr-2.png&#34; alt=&#34;PRの特定行のコードに対するコメント&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;特定行を指定し、コメントをいれる事も可能。（これは従来からある形らしい）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;備考&#34;&gt;備考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;とりあえず慣れるため、適当にCommentから入れていくことにしようかと思た。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;中カテゴリ&#34;&gt;中カテゴリ&lt;/h4&gt;

&lt;h2 id=&#34;2018-07-26-learned&#34;&gt;2018/07/26 - Learned&lt;/h2&gt;

&lt;p&gt;7月26日（木）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;packge-json&#34;&gt;packge.json&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;dependenciesは全てで利用するもの&lt;/li&gt;
&lt;li&gt;devDependenciesは開発はている時のみ利用するもの

&lt;ul&gt;
&lt;li&gt;Linterやビルド関係のパッケージなど / ちなみにdevに追加する場合は「yarn add &amp;ndash;dev」で追加する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-27-learned&#34;&gt;2018/07/27 - Learned&lt;/h2&gt;

&lt;p&gt;7月27日（金）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/shibukawa/items/19ab5c381bbb2e09d0d9&#34;&gt;参考:イマドキのJavaScriptの書き方2018&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;もう覚えなくても良い書き方を解説されている為、学習計画上、無駄が減って非常にありがたい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;部分的に掻い摘んでメモしたい所のみ記載。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;babel&#34;&gt;babel&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;現状は &lt;code&gt;preset-env&lt;/code&gt; 使っておきゃいい&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;変数&#34;&gt;変数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;こまけー事はいいから &lt;code&gt;const&lt;/code&gt; 使っときゃいい&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;関数宣言&#34;&gt;関数宣言&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;こまけー事はいいから &lt;code&gt;アロー関数&lt;/code&gt; 使っとけばいい。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt; は殺す&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const hoge = () =&amp;gt; {
  
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;非同期処理&#34;&gt;非同期処理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;こまけー事はいいから、 &lt;code&gt;async / await&lt;/code&gt; 使っときやいい。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;then()&lt;/code&gt;も殺す&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async&lt;/code&gt;つけたら、&lt;code&gt;await&lt;/code&gt;ついてるやつが待ってくれるようになる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;関数に引数セットを配列で渡す場合&#34;&gt;関数に引数セットを配列で渡す場合&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apply()&lt;/code&gt;は使わない&lt;/li&gt;
&lt;li&gt;スプレッド演算子 &lt;code&gt;...&lt;/code&gt; 使う。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/07 - thaad week I Learned</title>
      <link>https://kglabo.com/blog/til-201807-thaad-week/</link>
      <pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201807-thaad-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;数日間、海外に行っていたので抜けておりまする。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- tags = [&#34;Linux Command&#34;, &#34;正規表現&#34;, &#34;React&#34;] --&gt;

&lt;h2 id=&#34;2018-07-19-learned&#34;&gt;2018/07/19 - Learned&lt;/h2&gt;

&lt;p&gt;7月19日（木）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;tail-head-command&#34;&gt;tail/head Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ファイルの内容を部分的に閲覧する事が可能。

&lt;ul&gt;
&lt;li&gt;「tail（尾）」がファイルの末尾10行（default）だけを表示する&lt;/li&gt;
&lt;li&gt;「head(頭)」がファイルの先頭10行（default）だけを表示する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;（tailは前にも書いたけど復習もこめて）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;head-command&#34;&gt;head Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;head {オプション} {ファイル名}&lt;/code&gt;の形で実行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head -n {行数} {ファイル名}&lt;/code&gt; で 取得・表示する行数を指定する事が可能。

&lt;ul&gt;
&lt;li&gt;他に -c / -q / -v などのオプションも存在するが使い所はあんまりわからなかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{他のコマンド} | head&lt;/code&gt; とかみたいにパイプでつないでコマンド実行時の最初のログだけ確認したい時などに使える模様。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tail-command&#34;&gt;tail Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tail {オプション} {ファイル名}&lt;/code&gt;の形で実行。&lt;/li&gt;
&lt;li&gt;こちらも同じく、 &lt;code&gt;tail -n {行数} {ファイル名}&lt;/code&gt; で取得する行数を指定する事が可能。

&lt;ul&gt;
&lt;li&gt;head同様に、 -c / -q / -v などのオプションが存在するがry&lt;/li&gt;
&lt;li&gt;tailだけ &lt;code&gt;-f&lt;/code&gt;/ &lt;code&gt;-F&lt;/code&gt;などのファイルを監視して変更があったら追加表示していくオプションが存在する。&lt;/li&gt;
&lt;li&gt;違いとしては、監視するファイル名が変更された際に再度オープンするのが &lt;code&gt;-F&lt;/code&gt;で、そのまま開き続けるのが &lt;code&gt;-f&lt;/code&gt;。基本的に&lt;code&gt;-F&lt;/code&gt;で良い気がする。
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;wc-command&#34;&gt;wc Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;word countの略。テキストファイルの行数や単語数をカウント。&lt;code&gt;wc {オプション} {ファイル名}&lt;/code&gt; で記載する。&lt;/li&gt;
&lt;li&gt;単語数とか行数とかバイト数を取得するときに使う&lt;/li&gt;
&lt;li&gt;オプションの種類は…

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c （--bytes）&lt;/code&gt; / バイト数を表示する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m（--chars）&lt;/code&gt; / 文字数を表示する（マルチバイト文字に対応）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l（--lines）&lt;/code&gt; / 改行の数を表示する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w（--words）&lt;/code&gt; / 単語数を表示する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L（--max-line-length）&lt;/code&gt; / 最も長い行の長さを表示する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;若干オプション名が覚えづらい感ある。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;grep-command&#34;&gt;grep Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Global Regular Expression Print（グローバル正規表現の表示）の略らしい。&lt;code&gt;grep {検索したい文字列} {検索したいテキストファイル}&lt;/code&gt;で検索する事が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/kamorits/items/db814666a133fb9ae892&#34;&gt;参考:grepってなあに？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-20-learned&#34;&gt;2018/07/20 - Learned&lt;/h2&gt;

&lt;p&gt;7月20日（金）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;正規表現&#34;&gt;正規表現&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/{検索ワード}/g&lt;/code&gt;で膨大なデータの中から指定文字を検索する事が可能。基本的には「文字列」と「メタ文字」の組み合わせである。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://anagrams.jp/blog/basic-of-regular-expression-for-ppc-account-manager/&#34;&gt;参考:運用型広告の運用者がおさえておきたい正規表現、基本の「き」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尚、全部&lt;a href=&#34;https://regexr.com/&#34;&gt;regexr.com&lt;/a&gt;で試してみた。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;一文字にマッチング&#34;&gt;一文字にマッチング&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\d&lt;/code&gt; - 0~9の数字 / &lt;code&gt;[0-9]に相当&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;活用例としては、 &lt;code&gt;\d+&lt;/code&gt;とか &lt;code&gt;\d*&lt;/code&gt;とか &lt;code&gt;\d?&lt;/code&gt;とか&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\D&lt;/code&gt; - 数字以外の文字 / &lt;code&gt;[^0-9]&lt;/code&gt;に相当&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\s&lt;/code&gt; - 空白文字・タブ・改行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\S&lt;/code&gt; - 空白文字・タブ・改行 以外の文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\w&lt;/code&gt; - アルファベット・数字・アンダースコア / &lt;code&gt;[A-Za-z0-9]&lt;/code&gt;に相当

&lt;ul&gt;
&lt;li&gt;活用例としては、 &lt;code&gt;\w+&lt;/code&gt;とか &lt;code&gt;\w*&lt;/code&gt;とか &lt;code&gt;\w?&lt;/code&gt;とか&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\W&lt;/code&gt; - アルファベット・数字・アンダースコア 以外 / &lt;code&gt;[^A-Za-z0-9]&lt;/code&gt;に相当&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;メタ文字&#34;&gt;メタ文字&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; - 任意の一文字

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/AKB4./g&lt;/code&gt;とすると、AKB4の次の1文字に何かが入った単語を検索してくれる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/ALB../g&lt;/code&gt;とすると、AKBの次の2文字に何かが入った単語を検索してくれる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt;自体を検索したい場合は、&lt;code&gt;\.&lt;/code&gt;という形でエスケープする必要がある。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;内のいずれかの文字

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[bc]at&lt;/code&gt;とした場合、 &lt;code&gt;bat&lt;/code&gt;,&lt;code&gt;cat&lt;/code&gt; でマッチする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[^bc]at&lt;/code&gt;とした場合は、指定した複数の文字のどれか1文字とマッチさせたくない場合なので、 &lt;code&gt;aat&lt;/code&gt;, &lt;code&gt;dat&lt;/code&gt;でマッチする&lt;/li&gt;
&lt;li&gt;文字の範囲指定も可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt;で、0から9まで / &lt;code&gt;\d&lt;/code&gt;に相当&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt;で、aからz（小文字） /&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z]&lt;/code&gt;で、AからZまで（大文字）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-zA-Z]&lt;/code&gt;で、aからz &amp;amp; AからZまで&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9a-zA-Z]&lt;/code&gt;で、0から9、aからz、AからZまで / &lt;code&gt;\w&lt;/code&gt;に相当&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; - 0回か1回の繰り返し / 直前の文字が全く無い or 1つだけ存在する場合にマッチ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; - 1回以上の繰り返し / 直前の文字が1個以上連続するものにマッチ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; - 0回以上の繰り返し / 直前の文字が無い or 直前の文字が1個以上連続するものにマッチする&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{m,n}&lt;/code&gt; - 最小m回で最大n回&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; - 文字列の先頭

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;^hoge&lt;/code&gt; - 行頭から始まるhogeという単語を検索する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; - 文字列の末尾

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hoge$&lt;/code&gt; - 行末からhogeという単語を検索する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; - いづれかにマッチさせたい場合

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat|dog|bird&lt;/code&gt; - &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;dog&lt;/code&gt;, &lt;code&gt;bird&lt;/code&gt;のいづれか単語にマッチする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt; - &lt;code&gt;()&lt;/code&gt;で囲む事でグルーピングする事ができる。下記のような感じで利用

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/item/(cat|dog|bird)&lt;/code&gt; - &lt;code&gt;/item/&lt;/code&gt;以降に&lt;code&gt;cat&lt;/code&gt;または&lt;code&gt;dog&lt;/code&gt;または&lt;code&gt;bird&lt;/code&gt;がある場合にマッチ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/(item/)*cat/&lt;/code&gt; - &lt;code&gt;item/&lt;/code&gt;が存在しないか存在する。かつ、&lt;code&gt;cat&lt;/code&gt;がある場合にマッチ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; - 直前の文字列がn個連続である場合にマッチ

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(ca){2}&lt;/code&gt;の場合は、cacaaという単語の&lt;code&gt;caca&lt;/code&gt;にマッチ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ca{2}&lt;/code&gt;の場合は、cacaaという単語の&lt;code&gt;caa&lt;/code&gt;にマッチ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;react&#34;&gt;React&lt;/h3&gt;

&lt;h4 id=&#34;設計時に考える事&#34;&gt;設計時に考える事&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Componentの分割とStateを誰に持たせるのかを事前に考えるたほうが良い。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;何をしたら、どういった事が実現されるのかを決める&lt;/li&gt;
&lt;li&gt;実現する為にどんなコンポーネントがいるのかを考える

&lt;ul&gt;
&lt;li&gt;大枠としてappコンポーネントがあり、その中に内包されるコンポーネントを考える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;それぞれのコンポーネントに対して、どのような情報（ステート）が必要なのかを考える&lt;/li&gt;
&lt;li&gt;コンポーネントから、情報（ステート）がどういう形で渡されていくのかを考える&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>2018/07 - Second week I Learned</title>
      <link>https://kglabo.com/blog/til-201807-second-week/</link>
      <pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201807-second-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [&#34;VSCode&#34;, &#34;Command Line&#34;] --&gt;

&lt;h2 id=&#34;2018-07-09-learned&#34;&gt;2018/07/09 - Learned&lt;/h2&gt;

&lt;p&gt;7月9日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;vscodeで独自のsyntaxhighlightを作る方法&#34;&gt;VSCodeで独自のSyntaxHighlightを作る方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;結論 : テンプレートエンジン&lt;code&gt;ect&lt;/code&gt;のSyntaxHighlightがSublimeText / Atomにはあるにも関わらず、VSCodeにはなかったので自作した。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yu-kgr/vscode-ect-syntax-highlight&#34;&gt;ect-highlight&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://prius.hateblo.jp/entry/2016/10/15/121707&#34;&gt;参考:Visual Studio CodeでPlane Text(.txt)で自分独自記法のハイライト表示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.kondoumh.com/entry/2018/01/12/084409&#34;&gt;参考:VS Code の ChangeLog 用 Extension を作成する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;ect.tmLanguageファイルを作成

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/peppage/language-ect&#34;&gt;atom用の設定ファイルを参考&lt;/a&gt;に用意。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;The Yo Code Visual Studio Code Extension Generator&lt;/code&gt;を使って、VS Code用にコンバートしつつ、生成されたファイルを微修正。&lt;/li&gt;
&lt;li&gt;VS Codeの指定箇所に配置する&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;所感&#34;&gt;所感&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;HTMLで表示していたのでHTMLLinterがエラー検知してやっかいだったのがでなくなって満足！&lt;/li&gt;
&lt;li&gt;尚、VS CodeのMarketへの公開方法はいまいちわからなかった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-10-learned&#34;&gt;2018/07/10 - Learned&lt;/h2&gt;

&lt;p&gt;7月10日（火）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;command-line&#34;&gt;Command Line&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://prog-8.com/lessons/commandline/study/1&#34;&gt;参考:progate コマンドライン学習コース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;（よくわかってなかったCommandだけ抜粋。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pwd-command&#34;&gt;pwd Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Print Working Directory&lt;/code&gt; の略。現在いるディレクトリがどこかを返してくれる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ls-command&#34;&gt;ls Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt;の略。カレントディレクトリ内のディレクトリやファイルが一覧で表示される&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;mv-command&#34;&gt;mv Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;move&lt;/code&gt; の略。ファイルの移動及び、同じディレクトリに違う名前で移動する事が可能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv  {移動させたいファイル名} {移動先のディレクトリ名}&lt;/code&gt; または、 &lt;code&gt;mv  {移動させたいディレクトリ名} {移動先のディレクトリ名}&lt;/code&gt; でデータを移動する事が出来る。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv {リネームしたいファイル名}&lt;/code&gt; &lt;code&gt;リネーム後のファイル名&lt;/code&gt; で、データの名称を変更する事も可能。&lt;/li&gt;
&lt;li&gt;moveなのになんで名前変更できるねん。ってツッコミに対してはコチラの記事が参考になった。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/junjis0203/items/9e8f642b04d9754f1139&#34;&gt;参考:mvでリネームができるわけをどこまで深く話せますか&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;cp-command&#34;&gt;cp Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;copy&lt;/code&gt; の略。ファイルのコピーを行う。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp {コピーするファイル名} {コピーされる新しいファイル名}&lt;/code&gt; でファイルをコピーする事ができる。&lt;/li&gt;
&lt;li&gt;同様に&lt;code&gt;cp -r {コピーするディレクトリ名} {コピーされる新しいディレクトリ名}&lt;/code&gt; でディレクトリ単位でコピーする事ができる。

&lt;ul&gt;
&lt;li&gt;ディレクトリは&lt;code&gt;-r&lt;/code&gt;をつけないとコピーが実行されないので注意。&lt;/li&gt;
&lt;li&gt;尚、 &lt;code&gt;-r&lt;/code&gt;は&lt;code&gt;--recursive&lt;/code&gt;の略でコピー元にディレクトリを指定した場合、再帰的に（サブディレクトリも含めて）コピーするという意味らしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rm-command&#34;&gt;rm Command&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;remove&lt;/code&gt; の略。ファイルの削除を行う。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm {削除するファイル名}&lt;/code&gt;でファイルを削除する事ができる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -r {削除するディレクトリ名}&lt;/code&gt; でディレクトリを削除する事ができる。

&lt;ul&gt;
&lt;li&gt;こちらもディレクトリは&lt;code&gt;-r&lt;/code&gt;をつけないと削除が実行されないので注意。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-11-learned&#34;&gt;2018/07/11 - Learned&lt;/h2&gt;

&lt;p&gt;7月11日（水）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;confluenceでstylusを有効活用&#34;&gt;Confluenceでstylusを有効活用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;捜し物したい時にConfluence開いたら「人気の投稿」が気になってしまう対策&lt;/li&gt;
&lt;li&gt;stylus使ってConfluence用のカスタムスタイル作成して、「全ての更新」と「人気のコンテンツ」を非表示にするというパワープレイ。

&lt;ul&gt;
&lt;li&gt;必要に応じてスタイルをOFFにしたら見れるから無問題&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;#sidebar-discover  {
    display: none;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;macのtmpディレクトリとは一体&#34;&gt;Macのtmpディレクトリとは一体&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;「tmpにファイルを作成して試してみましょう」系で、そもそもtmpにファイル作って後々ゴミとかにならないの？大丈夫のの？って思ったので調べてみた。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/kuni-nakaji/items/f29be14be578b5a19d4b&#34;&gt;参考:/tmpと/var/tmpの仁義無き戦い&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tmp&#34;&gt;/tmp&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;このディレクトリはもともメモリの代わりに使用しようとしていたらしく、再起動時に内包するデータをクリアする仕様（思想？）&lt;/li&gt;
&lt;li&gt;性質的には

&lt;ul&gt;
&lt;li&gt;一時的ファイルを必要とするプログラムで使用&lt;/li&gt;
&lt;li&gt;再起動するとファイルは消える&lt;/li&gt;
&lt;li&gt;定期的に削除される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;var-tmp&#34;&gt;/var/tmp&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;同じtmpでも &lt;code&gt;var/tmp&lt;/code&gt;というtmpディレクトリも存在する模様。&lt;/li&gt;
&lt;li&gt;こちらの性質としては、

&lt;ul&gt;
&lt;li&gt;再起動してもファイルは消えない&lt;/li&gt;
&lt;li&gt;/tmpより長い期間保持されるが定期的に削除される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;という違いの模様。
&lt;code&gt;tmpにファイルを作成して試してみましょう&lt;/code&gt; の意図としては、&lt;br /&gt;
&lt;code&gt;放っといたら消える所だから安心してtmpに作成していろいろ試して見ましょう。&lt;/code&gt; という意味だと捉えた。スッキリ。&lt;/p&gt;

&lt;h3 id=&#34;ssh-command&#34;&gt;ssh Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;正式名称はSecure Shellでの接続。&lt;/li&gt;
&lt;li&gt;暗号や認証の技術を利用して、安全にリモートコンピュータと通信するためのプロトコル。パスワードなどの認証部分を含むすべてのネットワーク上の通信が暗号化される。&lt;/li&gt;
&lt;li&gt;ひと言で言うと、「PCに対して安全に接続する為の手法」のひとつ。接続先のポートは22番がウェルノウンポートとの事。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssh ユーザ名@ホスト名&lt;/code&gt; で接続可能。

&lt;ul&gt;
&lt;li&gt;名前解決ができれば、ホスト名の所はIP直打ちではなく&lt;code&gt;ssh ユーザー名@hoge.com&lt;/code&gt;のような形も可能。&lt;/li&gt;
&lt;li&gt;更に公開鍵/秘密鍵の登録を適切に行えばID/PASSでの接続ではなく、 &lt;code&gt;ssh ユーザ名@{接続先ホスト名} -i {秘密鍵名称}&lt;/code&gt;でパスワードの入力も不要になる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ウェルノウンポート&#34;&gt;ウェルノウンポート&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ウェルノウンポートとは、TCP/IPによる通信で利用されるTCPやUDPのポート番号のうち、著名なサービスやプロトコルが利用するために予約されている0番から1023番のこと。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://e-words.jp/w/%E3%82%A6%E3%82%A7%E3%83%AB%E3%83%8E%E3%82%A6%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88.html&#34;&gt;参考:ウェルノウンポートとは - IT用語辞典&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;HTTPの80番やFTPの20・21番、SMTPの25番、POP3の110番、DNSの53番などである。また、新しいプロトコルやサービスは1024番以降を利用することが慣例となっている。&lt;/li&gt;
&lt;li&gt;サーバ上でどのサービスをどのポートで動作させるかはソフトウェアによって設定できるようになっていることが多く、必ずしもウェルノウンポートでなければそのサービスを起動・利用できないわけではない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;テレビのチャンネル（デフォ設定）みたいなもんだと認識。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;sshrc&#34;&gt;sshrc&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;sshrc をインストールすれば、~/.sshrc に書いたコマンドをssh接続先の各サーバで実行してくれるらしい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ikuwow/items/ba4ca57fd67c06fd1b19&#34;&gt;参考:sshした先に.bashrcや.vimrcを持って行きたい人のためのsshrc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同じようなものDockerであったら便利じゃね？って思ったらあった。&lt;/p&gt;

&lt;h4 id=&#34;sshrc的なdocker-exec-it-用ラッパー&#34;&gt;sshrc的なdocker exec -it 用ラッパー&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ローカルに用意しておいた設定をコンテナ内に自動的に持っていく docker exec -it 用のラッパーらしい。

&lt;ul&gt;
&lt;li&gt;zsh / vim やらの自前環境をDocekr環境に持っていく事ができそう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://amaya382.hatenablog.jp/entry/2017/12/22/225555&#34;&gt;参考:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;scp-command&#34;&gt;scp Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Secure Copyの略。sshを利用してセキュリティを担保しつつ、ファイルの転送・コピーを行うコマンド。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ローカルからサーバにコピーする場合は、&lt;code&gt;scp {送りたいものの場所} {ユーザ名@ホスト名:配置先}&lt;/code&gt;の形で記載&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scp -i {ssh認証鍵の場所を指定} {送りたいものの場所} {ユーザ名@ホスト名:配置先}&lt;/code&gt;でパスワードの入力を省略できる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;サーバからローカルにコピーする場合は、 &lt;code&gt;scp {ユーザ名@ホスト名:送りたいものの場所} {配置先}&lt;/code&gt; でイケる&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;同じく　 &lt;code&gt;−i ｛ssh認証鍵の場所を指定｝&lt;/code&gt; でパスワード省略でイケる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-12-learned&#34;&gt;2018/07/12 - Learned&lt;/h2&gt;

&lt;p&gt;7月12日（木）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;ls-command-1&#34;&gt;ls Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ls Commandって&lt;code&gt;ls {ファイル名}&lt;/code&gt; で指定先の情報も取得できるのか・・・しらなんだ。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls -l {ファイル名}&lt;/code&gt;も可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tar-command&#34;&gt;tar Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Tape Archievesの略。その名の通り、元々は磁気テープ向けにファイルをアーカイブするためのコマンドだったらしい。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/tatesuke/items/c5370823adc7772d55d8&#34;&gt;参考:tarコマンドについての素朴な疑問を調べた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tar -{オプション} {アーカイヴのファイル名} {アーカイヴするもの}&lt;/code&gt; で指定したファイルのアーカイヴ化が出来る。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;でアーカイブ化 / &lt;code&gt;-x&lt;/code&gt;で展開 / &lt;code&gt;-v&lt;/code&gt;で詳細表示 / &lt;code&gt;-f&lt;/code&gt;でアーカイブor展開するファイル名の指定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/07 - One week I Learned</title>
      <link>https://kglabo.com/blog/til-201807-one-week/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201807-one-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [&#34;ssh&#34;, &#34;PermissionError&#34;, &#34;git&#34;, &#34;marge&#34;, &#34;rebase&#34;, &#34;学習サービス&#34;, &#34;docker&#34;] --&gt;

&lt;h2 id=&#34;2018-07-02-learned&#34;&gt;2018/07/02 - Learned&lt;/h2&gt;

&lt;p&gt;7月2日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;ssh接続時のpermissionerrorについて&#34;&gt;ssh接続時のPermissionErrorについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ssh keyのパーミッションがなんらかの理由で足りなくなる事があるらしいので、ちゃんと600設定してあげないといけない&lt;/li&gt;
&lt;li&gt;複数のssh keyがある場合に発生する模様？&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/midasmn/items/5295f6799aa407f0fdcf&#34;&gt;参考:MacのSSH接続でPermission denied (publickey)が出た時のおまじない&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-03-learned&#34;&gt;2018/07/03 - Learned&lt;/h2&gt;

&lt;p&gt;7月3日（火）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;gitのmargeとrebaseについて&#34;&gt;gitのmargeとrebaseについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;そういえば、branchを切ってからは基本的にPR飛ばしてからguthubやbitbucket側でmergeしてたから、margeとrebaseした事ない。&lt;/li&gt;
&lt;li&gt;hogeブランチとmasterブランチがある場合で考える。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;margeの場合&#34;&gt;margeの場合&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;masterブランチにhogeブランチを差し出すスタイル。&lt;/li&gt;
&lt;li&gt;masterブランチのケツにhogeブランチコミットを乗せる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;rebaceの場合&#34;&gt;rebaceの場合&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;masterブランチの内容をhogeブランチに持ってくるスタイル。&lt;/li&gt;
&lt;li&gt;名前の通り、hogeブランチ側の最初に最新のmasterブランチの内容をもってきて改変する&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;備考&#34;&gt;備考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;チームの運用ルールにもよるが、rebaseは不要なコミットログをひとまとめにする際に利用されるケースが多そう。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;progateとcodeprepについて&#34;&gt;progateとcodeprepについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;progateは実際に書かせる奴で、codeprepは穴埋めドリルやらせる奴。&lt;/li&gt;
&lt;li&gt;個人的にはprogateで感覚掴んで、udemyで更になるほど感を高めた上でなんか作ってみるのが一番スムーズな気がする&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-07-04-learned&#34;&gt;2018/07/04 - Learned&lt;/h2&gt;

&lt;p&gt;7月4日（水）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stylishというGoogle拡張があり「webページのstyleを個人的に変更するだけ」なんだけど、何に使えるのやらとずっと思ってた所、ブラウザベースで利用するようなアプリケーションとかでサービスとしてはとても優秀だけど「ちょっと見づらい・使いにくい」をこっちで勝手に解決しちゃうという使い方が出来る事が判明。これは便利。

&lt;ul&gt;
&lt;li&gt;便利。と思った瞬間、ユーザー情報を勝手に取得しているという記事が湧いててできたので代替アプリのstylusに変更した。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;docker&#34;&gt;docker&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;様々な用途に利用されるサーバの環境を簡単に用意できるやつ。&lt;/li&gt;
&lt;li&gt;僕/みんなの考えた最強のサーバ環境みたいなテンプレ（dockerイメージ）を元にして、手元に同じ環境（dockerコンテナ）を簡単に用意する事が出来る。

&lt;ul&gt;
&lt;li&gt;ちなみに環境をDockerに閉じ込める事をDockerizeというらしい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ザックリしたdokcer-docker-conposeの違い&#34;&gt;ザックリしたdokcer / docker-conposeの違い&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker ***&lt;/code&gt;はdockerコンテナ単体に対してなにかする処理&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;docker-compose ***&lt;/code&gt;はdockerコンテナ複数に対してなにかしてくれる処理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;コンテナに対して個別でなにかしないといけない時は&lt;code&gt;docker ***&lt;/code&gt; をする事がある&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker logs ***&lt;/code&gt; でコンテナのサーバログを追っかけたり&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker exec -it **** /bin/bash&lt;/code&gt; でコンテナのサーバーにログインしたり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;構成された環境をまとめて立ち上げる処理等に関しては&lt;code&gt;docker-compose ***&lt;/code&gt;を行う&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker ***&lt;/code&gt; コマンドで個別に立ち上げていく事も可能だが、それぞれのコンテナを起動する時に適切なオプションを指定してあげないととうまく連携しない。めんどくさい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yml&lt;/code&gt;というファイルを用意して、起動時のオプションを記述しておく事でそれを起動時に参照していい感じに処理してくれる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dockerコンテナを作りかた&#34;&gt;Dockerコンテナを作りかた&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Dockerfileを元にDockerイメージを作成
a. DockerHubからもってくる場合は、既に用意されているDockerイメージがあるのでDockerfileは不要&lt;/li&gt;
&lt;li&gt;Dockerイメージを元にDockerコンテナを作成&lt;/li&gt;
&lt;li&gt;出来た！&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;dockerコンテナの性質&#34;&gt;Dockerコンテナの性質&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;docker run --name sample1 -p 8090:80 -d nginx&lt;/code&gt; のひと文でnginxサーバーが構築できちゃう。すごい。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;自分で名前をつけれる（&lt;code&gt;--name sample1&lt;/code&gt;つけてる）&lt;/li&gt;
&lt;li&gt;名前の重複は不可（もう一個作る場合はsample1を消すか別名で）&lt;/li&gt;
&lt;li&gt;コンテナはCreated（作成した状態）、Up（起動している状態）、Exit（終了した状態）などの状態を持つ&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run&lt;/code&gt; は Created -&amp;gt; upまで一気にやっちゃう&lt;/li&gt;
&lt;li&gt;コンテナは終了しないと削除できない&lt;/li&gt;
&lt;li&gt;コンテナは閉じた世界&lt;/li&gt;
&lt;li&gt;コンテナの世界から自分のPCに対して、必要に応じて穴をあける事が可能。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--name ****&lt;/code&gt;はコンテナに名前をつける&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p 8090:80&lt;/code&gt;はDockerコンテナ側では80番でnginxが起動しているのを、自PC側では8090番に紐づけして穴を開ける指定をしている&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;webサーバとしてhtml表示してみる&#34;&gt;WebサーバとしてHTML表示してみる&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;nginxで指定されているwebサーバのドキュメントルートとローカルのディレクトリのパスを関連付けると表示出来る。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;docker run --name sample1 -p 8090:80 -v $PWD/web:/usr/share/nginx/html -d nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v $PWD/web:use/share/nginx/html&lt;/code&gt; の箇所で &lt;code&gt;-v [自PC側のファイルパス]:[Docker側のファイルパス]&lt;/code&gt;で穴を開ける（&lt;code&gt;$PWD&lt;/code&gt; は現時点で自分がいるディレクトリらしい）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/06 - Thaad week I Learned</title>
      <link>https://kglabo.com/blog/til-201806-thaad-week/</link>
      <pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201806-thaad-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [&#34;スタートアップ&#34;, &#34;hjson&#34;, &#34;Linux Command&#34;, &#34;ルーティング&#34;, &#34;&#34;] --&gt;

&lt;h2 id=&#34;2018-06-18-learned&#34;&gt;2018/06/18 - Learned&lt;/h2&gt;

&lt;p&gt;6月18日（月）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;なんか少しずつ新しく知った知見をまとめつ思ったのが、一旦小さくてもいいからアプリケーションをゼロから構築したほうが「あ、あれは◯◯でやった奴や」的な進研ゼミ的な体験が出来る気がしてきたので作って見ようかと思う。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ベンチャー企業とスタートアップ企業の違い&#34;&gt;ベンチャー企業とスタートアップ企業の違い&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;なんとなく思ってたので、あらためて「ほほう、そうなのか。」と思った事案。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.btrax.com/jp/2013/04/22/startup-2/&#34;&gt;参考:ベンチャー企業とスタートアップの違い&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;これで言うと最近のレシート10円買い取りサービスの「ONE」はスタートアップな気がする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ベンチャー企業&#34;&gt;ベンチャー企業&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ベンチャー・キャピタル（ハイリターンを狙ったアグレッシブな投資を行う投資会社）から投資を受けた企業の事を示すが、日本では新しく出来た小さな会社を示している事が多い。&lt;/li&gt;
&lt;li&gt;そもそも日本人が作った和製英語であり、外国では通じない。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;スタートアップ企業&#34;&gt;スタートアップ企業&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;新しいビジネスモデルを開発し、ごく短時間のうちに急激な成長とエクジットを狙う事で一獲千金を狙う人々の一時的な集合体。

&lt;ul&gt;
&lt;li&gt;存在意義は「今までに無いイノベーションを通じ、人々の生活と世の中を変える事」&lt;/li&gt;
&lt;li&gt;主に「全員が攻めに徹する“完全ぶっこみ型カミカゼチーム”」で構成される。&lt;/li&gt;
&lt;li&gt;最初の仕事は「ビジネスモデルを見つける事」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hjson-人が読めるjsonファイル&#34;&gt;hjson - 人が読めるjsonファイル&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://co.bsnws.net/article/131&#34;&gt;参考:コメントが書ける新しいjsonフォーマット「hjson」&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;hjsonとは、人が読めるようにコメントアウトが記述可能なjsonファイル&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Human JavaScript Object Notation&lt;/code&gt;の略らしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;過去、json内にkey名を重複される事でコメントを入れるという力技で処理していたので、もっと早くにこれを知りたかった。。。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ネットワーク-インフラ関係&#34;&gt;ネットワーク/インフラ関係&lt;/h3&gt;

&lt;h4 id=&#34;ルーティング&#34;&gt;ルーティング&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ルータがルーティングテーブルを参照してデータを正しい所に判断・誘導する仕組みをルーティングという。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://wa3.i-3-i.info/word1498.html&#34;&gt;参考:ルーティング (routing)とは&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;各フレームワークでのルーティング&#34;&gt;各フレームワークでのルーティング&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Reactの場合はこんなかんじ - &lt;a href=&#34;https://qiita.com/nakamura_hikaru/items/288ddc802b00ca1d191e&#34;&gt;React.jsでルーティングします。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Expressの場合はこんなかんじ - &lt;a href=&#34;http://expressjs.com/ja/starter/basic-routing.html&#34;&gt;Expressの基本的なルーティング&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linux-command&#34;&gt;Linux Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touch {ファイル名}&lt;/code&gt;でファイルが存在しない場合はファイルを生成できる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo {記載したい内容} &amp;gt;&amp;gt; {ファイル名}&lt;/code&gt; で該当ファイルに対して、文字を追加出来る&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo {記載したい内容} &amp;gt; {ファイル名}&lt;/code&gt;でbashの場合は該当ファイルの中身を上書き。

&lt;ul&gt;
&lt;li&gt;zshの場合はoverwriteする際は、&lt;code&gt;&amp;gt;&lt;/code&gt;ではなく&lt;code&gt;&amp;gt;!&lt;/code&gt;になる&lt;/li&gt;
&lt;li&gt;またzshの場合、文字列&lt;code&gt;[]&lt;/code&gt; がコマンド認識されて&lt;code&gt;no matches found:が返ってくるので&lt;/code&gt;&amp;rdquo;&amp;rdquo;`で囲む必要あり&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat {fileName}&lt;/code&gt; でファイル内容を表示可能。

&lt;ul&gt;
&lt;li&gt;前に記載していた pbcopyをパイプでつないで併用すると便利。 &lt;code&gt;cat {fileName} | pbcopy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-19-learned&#34;&gt;2018/06/19 - Learned&lt;/h2&gt;

&lt;p&gt;6月19日（火）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;喉がいがいがするなぁと思ったら風邪。風邪だと認識した時既に遅し。もっと早く気付ける仕組みがほしい。人間の体調も監視したい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;組織の話&#34;&gt;組織の話&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tinyurl.com/yb4rup4e&#34;&gt;参考:メルカリの小泉さんと組織の課題について話したら恐ろしい程勉強になった話&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://konifar.hatenablog.com/entry/2018/06/14/173716&#34;&gt;参考:Kyashに入社して半年くらい経ちました&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;なんかこういうの見てると「いろいろあるけどみんなでエモくガンガンいこうぜ。なんとかなるさ」って感想が出る（雑）&lt;/li&gt;
&lt;li&gt;みんな松岡修造見習っていくといいのではないかというひとつの結論が・・・！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;備考&#34;&gt;備考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;これ以降、6/27日までしばらく肺炎にてダウンしたのでおやすみタイム。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/06 - second week I Learned</title>
      <link>https://kglabo.com/blog/til-201806-second-week/</link>
      <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201806-second-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;git&#34;, &#34;ヘッドレスブラウザ&#34;, &#34;MultiAZ&#34;, &#34;リージョン&#34;, &#34;Availability Zone&#34;, &#34;Amazon Elastic Container Registry&#34;, &#34;Amazon Elastic Container Service&#34;, &#34;DOMContentLoadedイベント&#34;, &#34;Docker&#34;, &#34;Key Management Service&#34;, &#34;pbcopy&#34;, &#34;jq&#34;, &#34;tail&#34;, &#34;kzrb&#34;] --&gt;

&lt;h2 id=&#34;2018-06-11-learned&#34;&gt;2018/06/11 - Learned&lt;/h2&gt;

&lt;p&gt;6月11日（月）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ついに金沢も梅雨に入りました。そろそろ除湿機がほしい。&lt;/li&gt;
&lt;li&gt;そういえばRSSで購読してるTECHNICAL-CREATORブログさんで、今ちょうど読み勧めているフロントエンド・パンダ本について記事書かれてた。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://technical-creator.com/first-frontend-dev/&#34;&gt;テクニカルクリエイター.com - はじめてのフロントエンド開発」を読みました。JSフレームワークに今触れるならコレ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gitについて&#34;&gt;gitについて&lt;/h3&gt;

&lt;h4 id=&#34;コミットした時のコメント内容を修正&#34;&gt;コミットした時のコメント内容を修正&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;typo comment&amp;quot;&lt;/code&gt; した後は、 &lt;code&gt;git commit --amend -m &amp;quot;correct comment&amp;quot;&lt;/code&gt; で修正できる`&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;直近のコメントをまとめたい&#34;&gt;直近のコメントをまとめたい&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;git rebase -i HEAD~2&lt;/code&gt; で、 最新2件のコミットをまとめる事ができる。
　&lt;/p&gt;

&lt;h4 id=&#34;指定したブランチを追従して-コミットを適用し直す&#34;&gt;指定したブランチを追従して、コミットを適用し直す&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git rebase origin/master&lt;/code&gt; でOK。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;phantomjsとcasperjs&#34;&gt;PhantomJSとCasperJS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ヘッドレスブラウザとそれを簡単に動かす為のものらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;phantomjsとは&#34;&gt;PhantomJSとは&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JavaScriptを使用してスクリプトを作成できるヘッドレスWebブラウザ。マルチプラットフォームに対応している。&lt;/li&gt;
&lt;li&gt;GUIがないだけで、ブラウザでできる事は一通り行う事が可能『PhantomJS（CUIブラウザ）』&lt;/li&gt;
&lt;li&gt;主にテストフレームワーク（Mochaとか）と組み合わせ利用される事が多い。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/uest_kensington/items/82cd6978b4ac7afa6fdf&#34;&gt;参考:PhantomJSとは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://phantomjs.org/&#34;&gt;参考:PhantomJS - Scriptable Headless Browser&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;casperjsとは&#34;&gt;CasperJSとは&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;上記のPhamtomJSを簡単に利用する事ができるようにするライブラリ&lt;/li&gt;
&lt;li&gt;Phantom（幽霊・亡霊）に対して1995年/アメリカ映画に出てくる少年ゴーストと同名な所が捻られてて面白い。&lt;/li&gt;
&lt;li&gt;別のヘッドレスブラウザのSlimerJS（Firefox/Gecko）にも対応している。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/a-kane/items/a5d4b8345bc9c5d2c15c&#34;&gt;参考:CasperJSでブラウザ操作を自動化しよう&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tam-tam.co.jp/tipsnote/javascript/post8686.html&#34;&gt;参考:PhantomJS と CasperJS で複数ページを一括キャプチャする&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cheerio-httpcliについて&#34;&gt;cheerio-httpcliについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsで静的サイトをスクレイピング/解析を行う事ができるモジュール。&lt;/li&gt;
&lt;li&gt;jQueryライクに操作可能 / UTF-8に自動変換 / ブラウザ指定でのUser-Agent切替可能。&lt;/li&gt;
&lt;li&gt;ただ、対応しているNode.jsのバージョンが古いのと動的解析はできないので注意&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ktty1220/items/e9e42247ede476d04ce2&#34;&gt;参考:Node.js用のスクレイピングモジュール「cheerio-httpcli」の紹介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ktty1220/cheerio-httpcli&#34;&gt;参考:cheerio-httpcli - Node.js用WEBスクレイピングモジュール&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2018-06-12-learned&#34;&gt;2018/06/12 - Learned&lt;/h2&gt;

&lt;p&gt;6月12日（火）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;昨日出ていたPhantomJSのリポジトリがアーカイブされた模様。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jser.info/2018/06/11/phantomjs-ended/&#34;&gt;参考:JSer.info - PhantomJSの開発が終了しリポジトリがアーカイブ化された&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;しかし、昨今はヘッドレスChromeやヘッドレスFirefoxを各社ブラウザベンダーが公式配布している模様。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/updates/2017/04/headless-chrome?hl=ja&#34;&gt;参考:ヘッドレスChrome ことはじめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dev.classmethod.jp/client-side/browser/chromeless/&#34;&gt;参考:ヘッドレスChromeの自動化ツール「Chromeless」を使って自動テストを実施する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;awsに関するもの&#34;&gt;AWSに関するもの&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Web Serviceゥゥゥ！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multiazとは一体&#34;&gt;MultiAZとは一体&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;なんかサーバの&lt;a href=&#34;https://www.idcf.jp/words/redundant.html&#34;&gt;冗長化&lt;/a&gt;だったり&lt;a href=&#34;https://www.idcf.jp/words/dr.html&#34;&gt;ディザスタリカバリ&lt;/a&gt;に関係するものの模様。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/using-regions-availability-zones.html&#34;&gt;参考:リージョンとアベイラビリティーゾーン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://natural-hokke.hateblo.jp/entry/2014/10/24/133205&#34;&gt;参考:AWSのMultiAZについて調べたので残しておく&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;リージョンついて&#34;&gt;リージョンついて&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;世界中の各地方に分散して用意された単一のデーターセンターが置いてある地域のこと（同じ国に複数ある事もある）&lt;/li&gt;
&lt;li&gt;{{地名}}リージョンみたいな呼び方する（東京リージョン / オレゴンリージョン）

&lt;ul&gt;
&lt;li&gt;2018年2月頃、&lt;a href=&#34;https://dev.classmethod.jp/cloud/release-osaka-local-region/&#34;&gt;大阪リージョンも出来た模様。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/about-aws/global-infrastructure/&#34;&gt;参考:グローバルインフラストラクチャ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;availability-zone-az-ついて&#34;&gt;Availability Zone（AZ）ついて&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;各リージョン（Tokyo/Oregon/Frankfurtなど）内で、物理的に離れた箇所にあるデータセンターのこと。&lt;/li&gt;
&lt;li&gt;Tokyoリージョン内にも複数のAvailabilityZoneが存在する。&lt;/li&gt;
&lt;li&gt;各ユーザーが利用するリージョンが同じものになるとは限らない。

&lt;ul&gt;
&lt;li&gt;ユーザAは&lt;code&gt;ap-northeast-1a&lt;/code&gt;が利用されたが、ユーザBは&lt;code&gt;ap-northeast-1b&lt;/code&gt;を利用される…等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-Markdown&#34;&gt;# Tokyo リージョンの場合

- ap-northeast-1a
- ap-northeast-1b
- ap-northeast-1c
- ap-northeast-1d
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;multi-azについて&#34;&gt;Multi-AZについて&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;サービスを１つのAZで構成したもの（EC2/RDS/ELB等）は&lt;code&gt;Single-AZ&lt;/code&gt;と呼び、ービスを複数のAZで構成したものを&lt;code&gt;Multi-AZ&lt;/code&gt;と呼ぶ。

&lt;ul&gt;
&lt;li&gt;AZ自体に障害があり、利用しているAZが死んだ場合にもサービスに影響を与えないようにする為に複数のAZで構築して障害耐性を上げる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;車の任意保険みたいなもの。AZが複数ある分、その分のコストはかかる。その代わりに…

&lt;ul&gt;
&lt;li&gt;EC2（Amazon Elastic Compute Cloud）       : 障害が起きてないAZが応答するのでダウンタイムが発生しない&lt;/li&gt;
&lt;li&gt;RDS（Amazon Relational Database Service） : 勝手に切り替わる（自動フェイルオーバー）。1~6分程度かかる。インスタンスが2つなのでお金は2倍かかる&lt;/li&gt;
&lt;li&gt;ELB（Amazon Elastic Load Balancing）      : CrossZone-LoadBalancingという設定を有効にしないとインスタンス数が違う場合、autoScaling時に負荷が偏るので注意。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;AZ単位の障害はメンテとか細かい不具合とか？ / リージョンでの障害はもはや大災害。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/saitotak/items/07931343bcb703b101f8&#34;&gt;AWS でいままで起きた大規模障害を振り返る&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;amazon-elastic-container-registry&#34;&gt;Amazon Elastic Container Registry&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通称、Amazon ECR。Dockerのコンテナイメージを保存しておく為のレジストリ（設定情報のDB）。&lt;/li&gt;
&lt;li&gt;ECRに保存されているコンテナイメージは後述のECSなどのサービスにデプロイする事が可能。&lt;/li&gt;
&lt;li&gt;コンテナのイメージ操作はDockerCLIから行う事が可能で、イメージ自体はS3に保存されている。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/jp/ecr/&#34;&gt;参考:Amazon Elastic Container Registryとは&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;amazon-elastic-container-service&#34;&gt;Amazon Elastic Container Service&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;コンテナ管理サービス。簡単にDockerコンテナを実行・停止・管理する事が可能。&lt;/li&gt;
&lt;li&gt;ざっくり言うと、クラスタ（複数のEC2インスタンスの上）で、FrontサーバとAPIサーバごとの役割に分けた個別のService（Dockerコンテナ）が動くかんじ。&lt;/li&gt;
&lt;li&gt;あとでちゃんと知ったほうが良さげな奴 : Cluster（クラスター）/ Task（タスク）/ Service（サービス）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/Welcome.html&#34;&gt;参考:Amazon Elastic Container Service とは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/NewGyu/items/9597ed2eda763bd504d7&#34;&gt;参考:Amazon EC2 Container Service(ECS)の概念整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.mpon.me/entry/2017/11/19/200000&#34;&gt;参考:ECSの概念を理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;2018-06-13-learned&#34;&gt;2018/06/13 - Learned&lt;/h2&gt;

&lt;p&gt;6月13日（水）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;梅雨突入にもかかわらず奇跡的に天気予報が一週間連続で雨ではない金沢…！（奇跡か）&lt;/li&gt;
&lt;li&gt;ゼルダBoWやってて、トロッコ重ねて空中浮遊してたら、ハイラル城のてっぺんに到着してしまい、道中のザコ敵・中ボス全てすっ飛ばしてガノンと戦う羽目になる事案が発生。意図せぬエンドロールを見る羽目に。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;seoについて&#34;&gt;SEOについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;GoogleはJSによるクライアントサイドのnoindex処理を非推奨としているので、表示したくないコンテンツがある場合はHTML自体に&lt;code&gt;noindex&lt;/code&gt;をちゃんと入れよう。&lt;/li&gt;
&lt;li&gt;現状、GooglebotはWebサイトを2回クロールしているが、1度目のクロールではJSレンダリングの解析はされず、2度目のクロールで解析されている。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.suzukikenichi.com/blog/adding-noindex-tag-with-javascript-isnt-recommended/&#34;&gt;参考:JavaScriptによるnoindex挿入をGoogleは推奨せず、JSレンダリングはセカンドウェーブのインデックス&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;domcontentloadedイベント&#34;&gt;DOMContentLoadedイベント&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;window.onload&lt;/code&gt; の場合は、&lt;code&gt;字句解析 -&amp;gt; 構文解析 -&amp;gt; DOM構築 -&amp;gt; 画像ファイル・サブフレームの読込み&lt;/code&gt;完了後に実行するが、&lt;code&gt;DOMContentLoaded イベント&lt;/code&gt;を利用した場合は、DOM構築したタイミングで処理を実行する。&lt;/li&gt;
&lt;li&gt;結果としてDOM解析が完了した時点で実行しても良い処理の場合は処理速度の向上が見込めるので最適なイベントを選択しよう。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// window.onload
window.onload = function() {
  return console.log(&#39;全ての画像とサブフレームのロードが完了後に処理&#39;);
};

// DOMContentLoaded
document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function(event) {
  return console.log(&#39;DOM構築が完了後に処理&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dockerはアプリケーションを開発（developing）・移動（shipping）・実行（running）するための、コンテナ型の仮想環境プラットフォーム&lt;/li&gt;
&lt;li&gt;VirtualBoxみたいにホストOS上で仮想マシンを立ち上げてゲストOSを動かすのではなく、ホストマシンのカーネルを共有する事で、ホスト側仮想化ソフト -&amp;gt; ゲストOSの分のいろいろな手間がかからない。&lt;/li&gt;
&lt;li&gt;環境をコード化して、共有することで複数人での同一な環境構築の手間が短縮できる・楽（雑）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/9en/items/f4eab2f61485a9f3885a&#34;&gt;参考:仮想環境についてまとめてみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/hogehoge1234/items/b68e78cc4acb42cdca3d&#34;&gt;参考:dockerで何ができるの？なんで使うの？を初心者がまとめる&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;TODO:カーネルを個別に変えたい場合ってどんなケースなの？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.docker.jp/engine/articles/dockerfile_best-practice.html&#34;&gt;参考:Docker-docs-ja&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;aws&#34;&gt;AWS&lt;/h3&gt;

&lt;h4 id=&#34;key-management-service&#34;&gt;Key Management Service&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;データキーをを使ってデータを暗号化できるが、データキーを紛失すると暗号化データが復号化されてしまうので、データキー自体を暗号化したマスターキーを用意。マスターキーはAWS側に保存できるよ。っていうサービス。&lt;/li&gt;
&lt;li&gt;リージョン毎にキーを管理する仕様。キーごとにアクセス範囲を設定可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.slideshare.net/torazuka/10key-management-service&#34;&gt;参考:10分でわかるKey Management Serviceの仕組み #cmdevio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;TODO:暗号化するべきデータの基準とは一体…。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;terminal&#34;&gt;Terminal&lt;/h3&gt;

&lt;h4 id=&#34;nodebrewのinstall-binaryについて&#34;&gt;nodebrewのinstall-binaryについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;〈毎回忘れるのでメモ〉node.jsのバージョンマネージャーnodebrewについて。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nodebrew install &amp;lt;version&amp;gt;&lt;/code&gt;にするとコンパイルありで、&lt;code&gt;nodebrew install-binary &amp;lt;version&amp;gt;&lt;/code&gt; にするとコンパイルないことによってインストールする時間が高速になる（およそ1/15程度の時間差があるとの事）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/yn-misaki/items/e92a47c662ea6d1236c1&#34;&gt;参考:Nodebrewを使ってNode.jsを超高速にインストールする方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ここまで調べて思った事「自分のPC環境は全て、anyenvで統一されているのでndenvでござった・・・:(」&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pbcopyが非常に便利&#34;&gt;pbcopyが非常に便利&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cat &amp;lt;filName&amp;gt; | pbcopy&lt;/code&gt; で指定したファイルの中身をコピペできる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub | pbcopy&lt;/code&gt; で公開鍵をコピーしたり、中身を共有したいファイルをコピペする時に便利。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-14-learned&#34;&gt;2018/06/14 - Learned&lt;/h2&gt;

&lt;p&gt;6月14日（木）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;梅雨なのに金沢晴れてる！すげー！&lt;/li&gt;
&lt;li&gt;このTILのスタンスとしては個人的に「◯◯ってなんだっけ」って思った時に見返す備忘録用。&lt;/li&gt;
&lt;li&gt;また、性格診断による私のタイプは、&lt;a href=&#34;https://www.16personalities.com/ja/esfp%E5%9E%8B%E3%81%AE%E6%80%A7%E6%A0%BC&#34;&gt;エンターテイナー型&lt;/a&gt;らしい&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;shell-command&#34;&gt;Shell Command&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;今日知った、気になったコマンドたち。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;jqコマンド&#34;&gt;jqコマンド&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;brew install jq&lt;/code&gt; で仲間入りしてくれる、JSONから簡単に値を抜き出したり、集計したり、整形して表示したりできるJSON用のgrepとかawkみたいなコマンド（らしい）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takeshinoda@github/items/2dec7a72930ec1f658af&#34;&gt;参考:jq コマンドを使う日常のご紹介&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;TODO:今度JSONファイルになんかする時に利用してみる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tail-f-コマンド&#34;&gt;tail -F コマンド&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ファイルの末尾をCLI上で表示してくれるコマンドだけど、&lt;code&gt;-F&lt;/code&gt;をつける事によって中身が更新されたりしても、そのまま続きを表示してくれる。&lt;/li&gt;
&lt;li&gt;error.logなどのファイルを見て問題解決を行いたい時に使うととても便利っぽい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/sakito/items/7f65e16f10b3d754f307&#34;&gt;参考:tailコマンドのオプション「f」と「F」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;todo&#34;&gt;TODO&lt;/h3&gt;

&lt;p&gt;追々ちゃんと理解したいもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;リバースプロキシについて | &lt;a href=&#34;http://wa3.i-3-i.info/word1755.html&#34;&gt;参考:リバースプロキシ|「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;KVS（Key-Value Store）について | &lt;a href=&#34;https://qiita.com/uenohara/items/23eb6ee1259f8a927445&#34;&gt;参考:KVS（Key-Value Store）とは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Redisについて &lt;a href=&#34;https://www.slideshare.net/yujiotani16/redis-76504393&#34;&gt;参考:Redisの特徴と活用方法について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Promiseとasync/awaiteについて | &lt;a href=&#34;https://qiita.com/nabepon/items/1be1e83b0d17ee4f42a9&#34;&gt;参考:Promise と async/await を始めからていねいに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-15-learned&#34;&gt;2018/06/15 - Learned&lt;/h2&gt;

&lt;p&gt;6月15日（金）のToday I Leaned.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminal/ShellCommandと表記ブレしてたが、そもそもこれはLinuxCommandという名称が正しいのではないか説&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;docker-1&#34;&gt;Docker&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dockerもっとわかりやすそうな資料あるやん！の巻

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://morizyun.github.io/docker/about-docker-command.html&#34;&gt;参考:Dockerでよく使うコマンドまとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/aild_arch_bfmv/items/d47caf37b79e855af95f&#34;&gt;参考:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dockerとdocker-composeの違い&#34;&gt;dockerとdocker-composeの違い&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;dockerはコンテナの元になるイメージから、コンテナを作成する。

&lt;ul&gt;
&lt;li&gt;コンストラクタからインスタンス作成するイメージ&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;react&#34;&gt;React&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Reactが推奨するコンポーネントの種類

&lt;ul&gt;
&lt;li&gt;コンテナーコンポーネント&lt;/li&gt;
&lt;li&gt;ロジック/処理を持つ事ができ、下記のプレゼンテーショナルコンポーネントを格納する。&lt;/li&gt;
&lt;li&gt;プレゼンテーショナルコンポーネント&lt;/li&gt;
&lt;li&gt;ロジックは持たず、状態毎のDOM（コンポーネント）をもつ。コンテナに格納される。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-16-learned&#34;&gt;2018/06/16 - Learned&lt;/h2&gt;

&lt;p&gt;6月15日（土）のToday I Leaned.&lt;br /&gt;
&lt;a href=&#34;https://kzrb.doorkeeper.jp/events/73677&#34;&gt;kanazawa.rb meetup #70&lt;/a&gt; に参加してきたので、ここ数日で出たTODOについて調べたりともくもくしてきました。&lt;/p&gt;

&lt;h3 id=&#34;todoをひたすら調べる&#34;&gt;TODOをひたすら調べる！&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下記、調べた &amp;amp; 人に聞いた（ありがとうございやす）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;docker-カーネルを個別に変えたい場合ってどんなケースなのか&#34;&gt;Docker - カーネルを個別に変えたい場合ってどんなケースなのか？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ケース: ホストOS自体を変えたい場合だったり、レジストリ自体を変えたい場合など&lt;/li&gt;
&lt;li&gt;結　論: 自分のように手元で開発環境を作りたいという用途くらいであれば、基本的には気にしなくて良さそうな感じだった。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;aws-key-management-service-kvs-で暗号化するべきデータとは一体&#34;&gt;AWS Key Management Service（KVS）で暗号化するべきデータとは一体&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;各サービスを特定するような個人情報に該当するもの。

&lt;ul&gt;
&lt;li&gt;id・pass / 認証情報 / 秘密鍵など&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;わかりやすく言うと「この◯◯はgithubに公開しちゃったら第三者に悪用されます」みたいなデータは該当（なるほど）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;httpie&#34;&gt;HTTPie&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CLIからいい感じにJSONとかを利用する事ができるらしい（？）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ytabuchi/items/02fa15ac209823a4d19f&#34;&gt;curlに変わる便利コマンドHTTPieを使ってみた&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;civic-hackとawsの話&#34;&gt;CIVIC HACKとAWSの話&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;CIVICHACKとは、主にレガシーかつ封建的な環境に対してTechアプローチを入れることでいい感じに問題解決を図ろうぜって言うやつ。

&lt;ul&gt;
&lt;li&gt;うちの経営企画室に近い匂いを感じる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;今回のAWSのイベントでは、各企業のプロダクトの紹介がされているショーケースの横にAmazon IoT Enterprise Buttonがあって、その場で「FBのいいね」ができるようになっていた模様。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ruby2-6-0について&#34;&gt;Ruby2.6.0について&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;現在はプレビュー版らしくおそらく年末あたりにリリース予定。&lt;/li&gt;
&lt;li&gt;終端なしRange（endless range）という機能が便利そう。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(1..10)&lt;/code&gt;  endress range じゃない今までの終端ありのRange&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(1..)&lt;/code&gt; # endress range&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;今までは冗長的な記述を行う必要があったが少ない記述量で実現したい事が実行できるようになるとの事。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;vue-vuex-nuxt&#34;&gt;vue+vuex+nuxt&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Local-Storageを使う際はなにかに注意しろ！（忘れた）&lt;/li&gt;
&lt;li&gt;NuxtのデフォルトサーバーはCache-controlしないのでCDNと組みわせるとやばい。

&lt;ul&gt;
&lt;li&gt;Nuxtで組み上げるとどれ使いますか？って聞かれるので別のもの（Koaとか）を使うと良いらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;promise-async-await&#34;&gt;Promise - async/await&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ちょうどこれからPromise, async/awaitを学習はじめる所なので参考にしよう。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/nabepon/items/1be1e83b0d17ee4f42a9&#34;&gt;参考:Promise と async/await を始めからていねいに&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://aligach.net/diary/20180526.html#p01&#34;&gt;ES2017のasync/awaitのキソ練習&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;運用ブレスト聞きながら思ったこと&#34;&gt;運用ブレスト聞きながら思ったこと&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;具体的な内容を記載するのは避けるけど…参考にしたい所が多い:-)

&lt;ul&gt;
&lt;li&gt;仕組み・運用づくりがうまい&lt;/li&gt;
&lt;li&gt;質問の仕方だったり説明の仕方がうまい&lt;/li&gt;
&lt;li&gt;結論として落とし所を見つけるのかうまい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;（ただ個人的に、どこまでの人が権限を持って運営してるのあんまりわかっていない）

&lt;ul&gt;
&lt;li&gt;後ほど聞いた所、5名くらいらしい（なるほど）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/06 - one week I Learned</title>
      <link>https://kglabo.com/blog/til-201806-one-week/</link>
      <pubDate>Fri, 08 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201806-one-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;JavaScript&#34;, &#34;プロトタイプ&#34;, &#34;UJIターン&#34;, &#34;オブジェクト指向&#34;, &#34;プロトタイプチェイン&#34;, &#34;ECMA Script&#34;, &#34;prototype&#34;, &#34;__proto__&#34;, &#34;AWS&#34;, &#34;IAM&#34;, &#34;チェンジマネジメント&#34;, &#34;レンダリングエンジン&#34;, &#34;JavaScriptエンジン&#34;] --&gt;

&lt;h2 id=&#34;2018-06-04-learned&#34;&gt;2018/06/04 - Learned&lt;/h2&gt;

&lt;p&gt;6月4日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;ターン現象の種類&#34;&gt;ターン現象の種類&lt;/h3&gt;

&lt;h4 id=&#34;下記をまとめてujiターン現象というらしい&#34;&gt;下記をまとめてUJIターン現象というらしい&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Uターン現象: 地方から都市へ移住したあと、再び地方へ移住&lt;/li&gt;
&lt;li&gt;Jターン現象: 地方から大規模な都市へ移住したあと、地方近くの中規模な都市へ移住&lt;/li&gt;
&lt;li&gt;Iターン現象: 地方から都市へ、または都市から地方へ移住&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;プロトタイプベースのオブジェクト指向言語&#34;&gt;プロトタイプベースのオブジェクト指向言語&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクト指向言語と総称されるプログラミング言語のうち、&lt;strong&gt;プロトタイプを基礎（ベース）として&lt;/strong&gt;オブジェクトを取り扱うもの。インスタンスベースとも呼ぶ。一方、クラスでおこなっているものをクラスベースとよぶ。

&lt;ul&gt;
&lt;li&gt;クラスベースは、オブジェクトの雛形として必ずクラスが存在。クラスをインスタンス化する事でオブジェクトが生成される。&lt;/li&gt;
&lt;li&gt;プロトタイプベースは、既存のオブジェクトを元（プロトタイプ）として、ユニークな特徴を付与する事で存在する。要は新しいオブジェクトを生成した時点で、すでに別のオブジェクト（プロトタイプ）を元に作られているという事。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;javaScriptはプロトタイプベースでオブジェクト指向を実現している言語。

&lt;ul&gt;
&lt;li&gt;ES2015でクラス構文が実装されて、クラスベースっぽくコードを記載する事ができるようになったが、これは糖衣構文（シンタックスシュガー）であり、プロトタイプベースの言語である事に変わりはない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%83%88%E3%82%BF%E3%82%A4%E3%83%97%E3%83%99%E3%83%BC%E3%82%B9&#34;&gt;参考:プロトタイプベースとは&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://teratail.com/questions/77753&#34;&gt;参考:プロトタイプベースのオブジェクト指向言語が広く使われていない理由は?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;厳密に言うと、JavaScriptは他のプロトタイプベースのオブジェクト指向言語と比較すると特殊らしく、その表現も少し異なるらしいが一般的にはプロトタイプヘースのオブジェクト指向言語と呼ばれている。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://jsstudy.hatenablog.com/entry/2017/03/29/181613&#34;&gt;参考:JavaScriptはプロトタイプベースのオブジェクト指向プログラミング言語ではない！？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;プロトタイプチェインとは&#34;&gt;プロトタイプチェインとは&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;自身のオブジェクトにないメソッド（機能）/ プロパティ（属性）を &lt;code&gt;__proto__&lt;/code&gt; に格納されている別のオブジェクトから連鎖的に検索して呼び出す仕組み。&lt;/li&gt;
&lt;li&gt;別のオブジェクト（プロトタイプ）にお願い（移譲）して特性（機能・属性）を持ってくる。
-&lt;a href=&#34;https://www.slideshare.net/yuka2py/javascript-23768378&#34;&gt;参考:最強オブジェクト指向言語 JavaScript 再入門！&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 元となるオブジェクト（プロトタイプ）
var objA = {
  name: &#39;Taro&#39;,
  say: function(){
    console.log(this.name + &#39;is My Dog&#39;);
  }
}

var objB = { name: &#39;Pochi&#39;};

// プロトタイプを参照
objB.__proto__ = objA; // __proto__でのアクセスは非推奨
objB = Object.create(objA); // こっちが推奨

// プロトタイプを参照
var objC = {}; // __proto__でのアクセスは非推奨
objC.__proto__ = objB; // こっちが推奨

objC.say(); // Pochi is My Dog
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;プロトタイプ系のキーワード&#34;&gt;プロトタイプ系のキーワード&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ややこしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;プロトタイプ&#34;&gt;プロトタイプ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;仕様上の概念 / 仕組みそのものを示す&lt;/li&gt;
&lt;li&gt;全てのオブジェクトは内部プロパティ&lt;code&gt;[[Prototype]]&lt;/code&gt;を持つ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;prototype&#34;&gt;prototype&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;関数式（function）で生成されるオブジェクトが持つプロパティのこと&lt;/li&gt;
&lt;li&gt;最上位の&lt;code&gt;Object.protorype&lt;/code&gt;までプロパティを探索する特性をもつ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;プロパティには何らかのオブジェクトが格納されている&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;プロトタイプチェインでは利用されない。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;proto&#34;&gt;&lt;strong&gt;proto&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Object.prototypeから継承されるアクセサメソッド

&lt;ul&gt;
&lt;li&gt;アクセサメソッドとは、オブジェクト内部のメンバ変数(属性、プロパティ)に外部からアクセスするために用意されたメソッドで、メンバ変数をオブジェクト内部に隠蔽し、外部から直接参照させないようにする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最上位の&lt;code&gt;Object.prototype.__proto__&lt;/code&gt;までプロパティを探索する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.prototype&lt;/code&gt;の&lt;code&gt;__proto__&lt;/code&gt;は&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;new でインスタンスを生成したとき、関数（コンストラクタ）の prototype へのアドレスを格納する&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;プロトタイプチェインでは利用されるけど、呼び出し時は非推奨&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;ecma-scriptについて&#34;&gt;ECMA Scriptについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ざっくり言うと、&lt;strong&gt;標準化されたJavaScriptのバージョン&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://azu.github.io/slide-what-is-ecmascript/&#34;&gt;参考:ECMAScriptとは何か？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;es-next&#34;&gt;ES.next&lt;/h4&gt;

&lt;p&gt;次期ECMAScriptの事をECMAScript nextや、ES.nextと言ったりするらしい。&lt;/p&gt;

&lt;h2 id=&#34;2018-06-05-learned&#34;&gt;2018/06/05 - Learned&lt;/h2&gt;

&lt;p&gt;6月5日（火）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;死んでました。最近、目を酷使しすぎての死亡パターンが多いので対策を考えたい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-06-learned&#34;&gt;2018/06/06 - Learned&lt;/h2&gt;

&lt;p&gt;6月6日（水）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;aws&#34;&gt;AWS&lt;/h3&gt;

&lt;h4 id=&#34;iam設定について&#34;&gt;IAM設定について&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;rootユーザーで触り続けるのも危険なので、適切な権限を付与したIAMユーザー及びグループを作成したい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ja_jp/IAM/latest/UserGuide/getting-started_create-admin-group.html&#34;&gt;参考:最初の IAM 管理者のユーザーおよびグループの作成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;チェンジマネジメント&#34;&gt;チェンジマネジメント&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;組織を変える基本・変革を成功させるチェンジ・マネジメントに必要な要因。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;Vision（先への見通し・構想）

&lt;ul&gt;
&lt;li&gt;「Vision（先への見通し・構想）」がない場合は「CONFUSION（混乱）」が起きる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Skills（技術）

&lt;ul&gt;
&lt;li&gt;「Skills（技術）」がない場合は「ANXUETY（不安）」が起きる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Incentives（人々の意思決定や行動を変化させるような要因）

&lt;ul&gt;
&lt;li&gt;「Incentives（人々の意思決定や行動を変化させるような要因）」がない場合は「RESISTANCE（抵抗）」が起きる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Resources（資産、財産）

&lt;ul&gt;
&lt;li&gt;「Resources（資産、財産）」がない場合は「FRUSTRATION（失望）」が起きる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ActionPlan（行動計画）

&lt;ul&gt;
&lt;li&gt;「ActionPlan（行動計画）」がない場合は「FALSE SATRT（誤った開始）」が起きる&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;上記の要因が全てあれば、正しくチェンジしていく事が可能。&lt;/li&gt;
&lt;li&gt;このtopicについては「経営学 / ミクロ経済」などが該当するらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;javascript-1&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;プロトタイプについて&#34;&gt;プロトタイプについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;prototype継承を利用したClass的実装を行った事がない方は、あまり意識した事がない可能性があるらしい。&lt;/li&gt;
&lt;li&gt;オブジェクトのプロパティとしてもメソッドは実装できてしまう為、prototypeでなければいけないということは原則無い&lt;/li&gt;
&lt;li&gt;ただし、ネイティブのメソッドや、他人が作ったオブジェクトのメソッド参照する時に、prototypeで遡ると、そのオブジェクトがどういう機能を有しているか認識できるというメリットがある。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/uupaa/WebModule/wiki/WebModulePattern&#34;&gt;参考:WebModulePattern（ES5でのプロトタイプ継承 - ベストプラクティス）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;オブジェクトの生成&#34;&gt;オブジェクトの生成&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;new演算子とコンストラクタ関数によるオブジェクト生成。&lt;/li&gt;
&lt;li&gt;JavaScriptにおけるオブジェクト生成でよく見られるコード&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;コンストラクタ関数の定義を行う&lt;/li&gt;
&lt;li&gt;prototypeの拡張を行う&lt;/li&gt;
&lt;li&gt;上記で用意したものを利用する&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;(function(){

// 1. コンストラクタ関数の定義
var Person = function (name) {
  this.name = name;
}

// 2. prototypeの拡張
Person.prototype.name = &#39;nanashi&#39;;
Person.prototype.say = function() {
  console.log(&#39;こんにちわ。私は&#39; + this.name + &#39;です。&#39;);
}
/* 1+2で下記のPerson.prototypeオブジェクトが作成される *//*
Person {
 prototype : {
   name: &#39;nanashi&#39;,
   say: function(){
     console.log(..（省略）..);
   }
 }
}*/

// こんな感じで呼び出し可能
console.log(Person.prototype.name); // &amp;quot;nanashi&amp;quot;
Person.prototype.say(); // &amp;quot;こんにちわ。私はnanashiです。&amp;quot;

// 利用
var japanese = new Person(&#39;Tanaka&#39;);
// 下記のような初期化が行われる

/*
//1. 新しいオブジェクトの生成
var japanese = {};

//2. プロトタイプのオブジェクトの参照を代入
// Person.prototypeオブジェクトの機能が、japaneseで利用できるようになる
japanese.__proto__ = Person.prototype;

//3. japaneseをthisに、コンストラクタ関数を実行
Person.apply(japanese, [&#39;Tanaka&#39;]);

//4. 完成したオブジェクトを返す
return japanese;

---

// 結果として、新しいオブジェクト japanese の __proto__は、
// Person.prototypeに入っているオブジェクトの参照を持つ

japanese: {
  name: &#39;Tanaka&#39;
  __proto__: {
    name: &#39;nanashi&#39;
    say: function(){...} // ※①
  }
}

*/

// Person.prototype が japanese.__proto__に代入された直後の為、同一性比較はtrue
console.log(japanese.__proto__ === Person.prototype); // true

// Callされるが、japanese上にはsayがない為
// __proto__を遡り、上記（※①）のsayを見つける。
// name は japanese上で見つける。
japanese.say(); // &amp;quot;こんにちわ。私はTanakaです。&amp;quot;

japanese.name = &#39;Satou&#39;; // japanes e のnameを更新
japanese.say(); // &amp;quot;こんにちわ。私はSatouです。&amp;quot;

Person.prototype.name = &#39;Suzuki&#39;; // Person.prototype.nameを変更
japanese.say(); // &amp;quot;こんにちわ。私はSatouです。&amp;quot;
// name は japanese で見つかるので結果に変更はない

delete japanese.name; // japanese自身のnameを削除
japanese.say(); // &amp;quot;こんにちわ。私はSuzukiです。&amp;quot;
// japanese自身がnameを持っていない為、say / name 共に __proto__から検索される

})();

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;proto-1&#34;&gt;&lt;strong&gt;proto&lt;/strong&gt;&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;プロトタイプチェインで検索されるプロトタイプオブジェクトが入っている。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;プロトタイプチェイン&lt;/strong&gt;で利用されるもの&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;prototype-1&#34;&gt;prototype&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;プロトタイプオブジェクトの控室&lt;/li&gt;
&lt;li&gt;newとコンストラクタ関数でオブジェクトを生成する際、&lt;code&gt;__proto__&lt;/code&gt;に代入される。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;オブジェクト生成&lt;/strong&gt;で利用されるもの&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-07-learned&#34;&gt;2018/06/07 - Learned&lt;/h2&gt;

&lt;p&gt;6月7日（木）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;es2015&#34;&gt;ES2015&lt;/h3&gt;

&lt;h4 id=&#34;class構文&#34;&gt;class構文&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;前日のptrototypeでのオブジェクト指向実装をclassに置き換えしてみる&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Person = function(name) {
  this.name = name;
}
Person.prototype.


---

class Person {
  constructor (name) {
    this.name = name;
  }
  say(){
    console.log(`こんにちわ。私は ${this.name} です。`);
  }
}

var japanese = new Person(&#39;Tanaka&#39;);
japanese.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ES5の時、prototypeの場合はnameメソッドをPeson関数に追加しているが、同様の事をclassでやるときってどうするのか？&lt;/li&gt;
&lt;li&gt;そもそもPersonをインスタンス化しないで追加したnameメソッドを参照できるのにClassの場合は同様の事が出来ない？

&lt;ul&gt;
&lt;li&gt;classの場合は、インスタンス化せずに呼び足す場合は&lt;code&gt;static&lt;/code&gt; メソッドを活用する他ない。&lt;/li&gt;
&lt;li&gt;prototypeは割となんでもあり感が強いので、オブジェクトのプロパティにしてしまうとか。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-06-08-learned&#34;&gt;2018/06/08 - Learned&lt;/h2&gt;

&lt;p&gt;6月8日（金）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;javascript-2&#34;&gt;JavaScript&lt;/h3&gt;

&lt;h4 id=&#34;thisの性質について&#34;&gt;thisの性質について&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisは特別な変数であり、利用される場所や呼び出し方によって中身が変化する。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;関数コール時にその関数が所属していたオブジェクトが&lt;code&gt;this&lt;/code&gt;になる。&lt;/li&gt;
&lt;li&gt;ただの関数で呼び出しした場合は、所属しているオブジェクトがないので、グローバルオブジェクトを呼出（ブラウザの場合は&lt;code&gt;windows&lt;/code&gt;オブジェクトが呼出）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;thisの性質を操る方法&#34;&gt;thisの性質を操る方法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;thisは標準的な利用方法だと上記の使い方になるが、呼び出し元でthisを操る事が可能メソッドが存在する&lt;/li&gt;
&lt;li&gt;関数オブジェクトにはthisをコントロールする事が可能な3つのメソッドが存在する（関数オブジェクトのみ）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;callメソッド&#34;&gt;callメソッド&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;こんなかんじ。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;call(
  object, // objectが関数内でのthisになり
  arg1, atg2, ... // その後の引数は関数呼び出し時に与える引数になる
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;callとapplyは関数を実行する&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Person = function(name){
  this.name = name;
}

function say(arg1, arg2){
  alert(arg1 + this.name + atg2);
}

var person = new Person(&#39;Tanaka&#39;);

// callの第一引数がthisになり、第二引数以降がsay関数の引数になる
say.call(person, &#39;Hello&#39;,&#39;san&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数はオブジェクトに束縛されていない為、他のオブジェクトのメンバ（ローカル変数）だったとしても関係がない&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;applyメソッド&#34;&gt;applyメソッド&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;こんなかんじ&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;apply(
  object, // objectが関数内でのthisになり
  Array // その後の因数は関数呼び出し時に与える因数になる
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;callとapplyは関数を実行する&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Person = function(name){
  this.name = name;
}

function say(arg1, arg2){
  alert(arg1 + this.name + atg2);
}

var person = new Person(&#39;Tanaka&#39;);

// applyの第一引数がthisになり、第二引数以降がsay関数の引数になる
say.apply(person, [&#39;Hello&#39;,&#39;san&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数はオブジェクトに束縛されていない為、他のオブジェクトのメンバ（ローカル変数）だったとしても関係がない&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;bindメソッド&#34;&gt;bindメソッド&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;bind(
  object, // objectが関数内でのthisになり
  arg1, atg2, ... // その後の因数は関数呼び出し時に与える因数になる
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;bindは関数に値を束縛する&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Person = function(name){
  this.name = name;
}

function say(arg1, arg2){
  alert(arg1 + this.name + atg2);
}

var person = new Person(&#39;Tanaka&#39;);

var say2 = say.bind(person); // personをthisにthisに束縛した新しい関数オブジェクトを返す
say2(&#39;Hello &#39;, &#39;san&#39;) // say2関数の呼び出しでは常にpersonがthisになる。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;javascriptエンジン&#34;&gt;JavaScriptエンジン&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;主要なブラウザのレンダリングエンジンとJavaScriptのエンジンは2018/06現在は下記の通り。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;google-chrome&#34;&gt;Google Chrome&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;レンダリングエンジン : Blink&lt;/li&gt;
&lt;li&gt;JavaScriptエンジン : V8&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;safari&#34;&gt;Safari&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;レンダリングエンジン : Webkit&lt;/li&gt;
&lt;li&gt;JavaScriptエンジン : JavaScriptCore&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;firefox&#34;&gt;Firefox&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;レンダリングエンジン : Gecko&lt;/li&gt;
&lt;li&gt;JavaScriptエンジン : SpiderMonkey&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;internet-explorer&#34;&gt;Internet Explorer&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;レンダリングエンジン : Trident&lt;/li&gt;
&lt;li&gt;JavaScriptエンジン : Chakra&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;雑感&#34;&gt;雑感&lt;/h3&gt;

&lt;p&gt;今週は、JavaScriptのObjectやprototypeベースでのオブジェクト指向、&lt;strong&gt;proto&lt;/strong&gt;やプロトタイプチェイン。&lt;br /&gt;
prototypeを利用したクラスの作成方法について学習。合わせてES2015のclass構文について少々。&lt;/p&gt;

&lt;p&gt;別途、Reactのチュートリアルを進行中。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2018/05 - four week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-four-week/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-four-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;ElasticSearch&#34;, &#34;javaScript&#34;, &#34;npm script&#34;, &#34;webpack&#34;, &#34;ES2015&#34;,&#34;マイクロワイヤーフレーム&#34;] --&gt;

&lt;h2 id=&#34;2018-05-28-learned&#34;&gt;2018/05/28 - Learned&lt;/h2&gt;

&lt;p&gt;5月28日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;elasticsearchについて&#34;&gt;ElasticSearchについて&lt;/h3&gt;

&lt;p&gt;Javaで記述された全文検索ソフトウェア。&lt;br /&gt;
あらかじめ蓄積した大量のデータから指定したキーワードを探し出す機能を持っており、javaのクラスライブラリとして提供されている。&lt;/p&gt;

&lt;h4 id=&#34;oracleやmysqlじゃだめなの&#34;&gt;OracleやMySQLじゃだめなの？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;DBによって得意不得意があって、全てのケースに対応しているものが存在しない為、使うと便利。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dbの種類&#34;&gt;DBの種類&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MySQL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;矛盾なく永続化することに特化したデータベース&lt;/li&gt;
&lt;li&gt;メリット: SQL と言う高度なクエリ言語、検索トラフィックに対するシステムの拡張は得意&lt;/li&gt;
&lt;li&gt;デメリット: データ量の増加や書き込み速度の拡張は苦手&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redshift(AWS)：データウェアハウス系のデータベース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メリット: 大規模なデータの蓄積・分析は得意&lt;/li&gt;
&lt;li&gt;デメリット: 不特定多数のクライアントから同時に利用され、検索リクエストが大規模なユースケースには不向き&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DynamoDB(AWS)：NoSQL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メリット: 幅広い種類の膨大な量のデータを高速かつ動的に整理し分析することが可能&lt;/li&gt;
&lt;li&gt;デメリット: 非リレーショナルな広域分散データベースシステムです。その反面複雑なクエリやソートなどが苦手&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;elasticsearchが得意なこと&#34;&gt;ElasticSearchが得意なこと&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;高度なリアルタイム分析&lt;/li&gt;
&lt;li&gt;大規模分散&lt;/li&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;マルチテナンシー&lt;/li&gt;
&lt;li&gt;全文検索&lt;/li&gt;
&lt;li&gt;ドキュメント指向&lt;/li&gt;
&lt;li&gt;スキーマフリー&lt;/li&gt;
&lt;li&gt;RESTfulAPI&lt;/li&gt;
&lt;li&gt;データ保護機能&lt;/li&gt;
&lt;li&gt;形態素解析や n-gram など自然言語的な解析&lt;/li&gt;
&lt;li&gt;簡単にスケールアウト&lt;/li&gt;
&lt;li&gt;kibanaと連携する事によって図で表示する事も可能！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;npm-scriptについて&#34;&gt;npm scriptについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;package.jsonのscriptフィールドにスクリプトを記載すると、コマンドのエイリアスを作成できる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot; : {
  &amp;quot;build:dev&amp;quot; : &amp;quot;webpack --mode development&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;webpack&#34;&gt;webpack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kglabo.com/blog/til-201805-thaad-week/#webpack%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6&#34;&gt;これの続き&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;loader&#34;&gt;Loader&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Loaderを利用する事で、JavaScript以外のファイルもstaticファイルも同時にbundleする事が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/loaders/&#34;&gt;いろいろな種類のloader&lt;/a&gt;が存在する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-29-learned&#34;&gt;2018/05/29 - Learned&lt;/h2&gt;

&lt;p&gt;5月29日（火）のToday I Leaned&lt;/p&gt;

&lt;h4 id=&#34;webpack-1&#34;&gt;webpack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;上記の続き&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;plagin&#34;&gt;Plagin&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Loaderはファイルの依存関係であった、モジュールタイプの変更に使えたが、PluginはLoaderで賄えない幅広いタスクの実行が可能になる。&lt;/li&gt;
&lt;li&gt;Pluginを利用する場合は、Moduleをrequireした後、new演算子を使ってインスタンス化する必要がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;es2015&#34;&gt;ES2015&lt;/h4&gt;

&lt;p&gt;なんか前にも学習してた気がするけど、間が空いてしまって忘れつつあるので、&lt;br /&gt;
改めて備忘録と後々見返す事を兼ねて記載く。&lt;/p&gt;

&lt;h5 id=&#34;ブロックスコープ&#34;&gt;ブロックスコープ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;varは関数定義の&lt;code&gt;{&lt;/code&gt;と&lt;code&gt;}&lt;/code&gt;内じゃないとスコープが作られないので、スコープを作りたい場合は即時関数を利用する必要がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 普通に{}でスコープ作った場合
{
  var a = &amp;quot;foo&amp;quot;;
}

if(true){
  var b = &amp;quot;bar&amp;quot;;
}

for(var i = 0; i &amp;lt; 1; i++){
  var c = &amp;quot;buz&amp;quot;;
}

console.log(a); // &amp;quot;foo&amp;quot;
console.log(b); // &amp;quot;bar&amp;quot;
console.log(c); // &amp;quot;buz&amp;quot;

// 即時関数を作った場合（スコープ作られる）
(function(){
  var a = &amp;quot;foo&amp;quot;;
})();

console.log(a); // ReferenceError: a is not defined

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;let/constは、varとは異なりブロックスコープ（&lt;code&gt;{&lt;/code&gt;と&lt;code&gt;}&lt;/code&gt;で囲まれた内部）でしか変数/関数の参照ができない

&lt;ul&gt;
&lt;li&gt;メリット 定義した変数・関数の影響範囲が明確化される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;{
  let   a = &amp;quot;foo&amp;quot;;
  const B = &amp;quot;bar&amp;quot;;

  console.log(a); // &amp;quot;foo&amp;quot;
  console.log(B); // &amp;quot;bar&amp;quot;
}

console.log(a);
// ReferenceError: a is not defined
console.log(B);
// ReferenceError: B is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;テンプレートリテラル&#34;&gt;テンプレートリテラル&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;文字列の連結の為に&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;concat()&lt;/code&gt;を利用する必要があったが、下記の形で変数名を参照する事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const user = { name: &#39;Taro&#39;};
console.log(\`${user.name}が入室しました。\`); // &amp;quot;Taroが入室しました、&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;計算式を入れる事も可能。変数が存在しない場合は&lt;code&gt;||&lt;/code&gt;を入れることで分岐される事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(\`${user.name||&amp;quot;匿名&amp;quot;}が入室しました。\`); // &amp;quot;匿名が入室しました、&amp;quot;

const user = {name: &#39;Taro&#39;};
console.log(\`${user.name||&amp;quot;匿名&amp;quot;}が入室しました。\`); // &amp;quot;Taroが入室しました、&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;デフォルト引数&#34;&gt;デフォルト引数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ES2015からは引数定義の箇所でデフォルト値を設定可能&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function joinChannel(name = &amp;quot;匿名&amp;quot;) {
  console.log(&#39;${name}さんが入室しました。&#39;)
}

// 匿名さんが入室しました。
joinChannel();

// 太郎さんが入室しました。
joinChannel(&amp;quot;太郎&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;アロー関数&#34;&gt;アロー関数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;関数定義を省略して書く事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 従来の記法
const add = function (a,b) {
  return a + b;
}

// functionを省略可能
const add = (a,b) =&amp;gt; {
  return a + b;
}

// 波括弧とreturnも省略できる場合
const add = (a,b) =&amp;gt; a + b;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2018-05-30-learned&#34;&gt;2018/05/30 - Learned&lt;/h2&gt;

&lt;p&gt;5月30日（水）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;理解度に合わせて基礎をいったり来たり。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;javascript&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;PrototypeとClass定義について&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;prototypeについて&#34;&gt;Prototypeについて&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ES2015以前は、classという概念がなかったのでJSの仕様でなんとかclassっぽい事を実現する為に運用でカバーしていたらしい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/howdy39/items/35729490b024ca295d6c&#34;&gt;図で理解するJavaScriptのプロトタイプチェーン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;class定義&#34;&gt;class定義&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;これまではクラス定義がなかったのでprototypeにメソッドを追加して対応していた。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Parson = function(id, name) {
  this.id = id;
  this.name = name;
}

Paeson.prototype.printName(){
  console.log(this.name);
}

var person = newPerson(1,太郎);
person.printName();

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2018-05-31-learned&#34;&gt;2018/05/31 - Learned&lt;/h2&gt;

&lt;p&gt;5月31日（木）のToday I Leaned&lt;/p&gt;

&lt;h4 id=&#34;javascript-1&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;prototypeやclass定義の所で一旦、JavaScript自体について知ったほうが良い気がした為一旦もどる。&lt;/li&gt;
&lt;li&gt;出てくる名称や独自仕様について。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;イベントとイベントハンドラ&#34;&gt;イベントとイベントハンドラ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;HTML要素に対してかかる（かける）名をイベントと呼び、そりによって起こる現象をイベントハンドラと呼ぶ。&lt;/li&gt;
&lt;li&gt;&amp;lt;要素名 onイベント名=“イベントハンドラ”&amp;gt;&amp;lt;/要素名&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;ホイスティング-巻き上げ&#34;&gt;ホイスティング（巻き上げ）&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;JavaScriptには変数を指定した時点、その宣言されたスコープ内で巻き上げ（ホイスティング）という現象が発生する仕様。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/cocottejs/items/143f70e806c61ffafe28&#34;&gt;参考:関数の場合の変数の巻き上げ問題について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/39_isao/items/d9d80e98b5bd1938bc1d&#34;&gt;参考:やっとわかったjsの「巻き上げ」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(x) // ReferenceError: x is not defined（そんなもんねーよ）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(x) // undefined（1かはわからんけど、xは存在してるよ）
var x = 1;

// ↓ 内部ではこんな事（ホイスティング）が起きてる
var x;
console.log(x);
x = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;関数定義について&#34;&gt;関数定義について&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;関数定義の方法が「関数宣言文」と「関数定義式」の二種類ある。

&lt;ul&gt;
&lt;li&gt;本質的な違いは「式（Expression）」か「文（Statement)」なのかの違い。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wp-p.info/tpl_rep.php?cat=js-intermediate&amp;amp;fl=r9&#34;&gt;参考:ホスティング宣言の巻き上げについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wp-p.info/tpl_rep.php?cat=js-intermediate&amp;amp;fl=r10&#34;&gt;参考:無名関数 関数式と関数宣言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/tomcky/items/988fc5f56d019e9dc097&#34;&gt;参考:【JavaScript】関数定義いろいろ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 関数宣言文
function hoge(){
  // ここに処理
}

// 関数定義式（関数リテラル）
var hoge = function (){
  // ここに処理
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数宣言文の場合は、関数宣言の前に関数を実行してもエラーにならない。&lt;/li&gt;
&lt;li&gt;なぜなら、関数宣言文の場合はブラウザでのレンダリングが完了した時点で関数が生成されている為、宣言する前に実行可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 関数宣言文を実行した場合
hoge(); // 先に呼ばれてるけど &amp;quot;hoge&amp;quot;と表示される

function hoge(){ // 関数宣言した場合は、レンダリングが完了した時点で関数生成済み
  console.log(&amp;quot;hoge&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数定義式（関数リテラル）の場合は、関数定義の前に関数を実行するとエラーになる。&lt;/li&gt;
&lt;li&gt;なぜなら、関数定義式の場合は変数に対して代入処理が行われた時点で初めて関数定義される為、代入後じゃないと実行不可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;hoge(); // Uncaught TypeError: hoge is not a function

var hoge = function (){
  console.log(&amp;quot;hoge&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;マイクロワイヤーフレーム&#34;&gt;マイクロワイヤーフレーム&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;マイクロワイヤーフレームという従来のワイヤーフレームを小さく（100px~300pxぐらいでサイズ決める）して良さを濃集したものがあるらしい。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://uxmilk.jp/66066&#34;&gt;参考:次世代のワイヤーフレーム「マイクロフレーム」とは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;効能 : つくるのはやい / わかりやすい / 忠実制が少ないので混乱しづらい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;利点&#34;&gt;利点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;はやい

&lt;ul&gt;
&lt;li&gt;スケッチと同じくらい早く作ることができる&lt;/li&gt;
&lt;li&gt;簡単に作業を繰り返すことができる&lt;/li&gt;
&lt;li&gt;すぐに結果共有が可能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;わかりやすい

&lt;ul&gt;
&lt;li&gt;プランや要件をわかりやすく伝えることができる&lt;/li&gt;
&lt;li&gt;顧客と協力して同じ視点で作業を反復することが可能&lt;/li&gt;
&lt;li&gt;WFのように捨ててしまう作品に時間をかけすぎない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;忠実性が低いので混乱が少ない

&lt;ul&gt;
&lt;li&gt;めっちゃ最小化されているので、完成品とのギャップを感じづらい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-6-01-learned&#34;&gt;2018/6/01 - Learned&lt;/h2&gt;

&lt;p&gt;6月01日（金）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;なんだか今週はJavaScript Week。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;javascript-2&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;関数オブジェクトやらコンストラクタ・インスタンス・クロージャ・プロトタイプなど&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;関数の即時実行と受け渡し&#34;&gt;関数の即時実行と受け渡し&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;javaScriptでは関数の即時実行が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/fewzio/items/a502defb516e75d7e81b&#34;&gt;参考:久しぶりにJavaScriptを思い出す(関数オブジェクト、クロージャ）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 普通に定義して実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) };
a(); // var aへの参照と実行 &amp;quot;TEST&amp;quot; と表示される
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) }(); // var aへの参照と実行 &amp;quot;TEST&amp;quot; と表示される
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ただ上記は、aに対して何のリテラルも代入しているわけではないので、&lt;code&gt;&amp;quot;TEST&amp;quot;&lt;/code&gt;がコンソールに表示された後、&lt;code&gt;undefined&lt;/code&gt; が出力される。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) }(); // &amp;quot;TEST&amp;quot;
console.log(a); // aには何も代入されていないのでundefined
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;a自体に値を代入したい場合は&lt;code&gt;return&lt;/code&gt;を利用すると戻り値に1が返ってくる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ return 1; }(); // aに1が代入される
console.log(a); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;JavaScriptでは関数を値と同じように受け渡しができるので、下記のように戻り値に関数を定義する事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 戻り値を関数にした場合
var a = function () {
  return function () { // 関数を実行した結果、後ろの関数がaに代入される
    console.log(&amp;quot;TEST&amp;quot;);
  }
}();

a(); // &amp;quot;TEST&amp;quot; &amp;amp; 上記の場合はaには何も代入されていないのでundefined（ややこしい）

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt;内にプロパティを定義したうえで関数を定義する事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 戻り値を関数にした場合
var a = function () {
  return {
    propA: function () { console.log(&amp;quot;A&amp;quot;); },
    propB: function () { console.log(&amp;quot;B&amp;quot;); },
  }
}();

a.propA(); //&amp;quot;A&amp;quot;
a.propB(); //&amp;quot;B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;クロージャ&#34;&gt;クロージャ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;関数内部で定義した関数を、代入した変数（オブジェクト）では、中の変数の値も保持し続ける。&lt;/li&gt;
&lt;li&gt;この変数値も保持し続ける関数をクロージャと呼ぶ。プライベート変数みたいなものらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var module = function() {
  var count = 0; //module関数の中で保持される変数（クロージャ）

  return {
    increment: function() {
      count++;
    },
    show: function() {
      console.log(count);
    }
  };

}();

module.show(); // 0
module.increment(); // countを+1する
module.show(); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;オブジェクト&#34;&gt;オブジェクト&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/yoshi389111/items/245df2d642e49d2acf3a&#34;&gt;参考:[JavaScript] オブジェクトの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScriptにおけるオブジェクトは、&lt;code&gt;{key: value}&lt;/code&gt;形式の入れ物（他言語の場合はハッシュテーブルとか連想配列というらしい）で関数も配列もオブジェクト。&lt;/li&gt;
&lt;li&gt;オブジェクトを生成してkey:valueを登録する場合は下記のように行える。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var obj = new Object();

// &amp;quot;hoge&amp;quot; というkeyに &amp;quot;hello&amp;quot; というvalueを登録
obj.hoge = &amp;quot;hello&amp;quot;;

// &amp;quot;func&amp;quot; というkeyに &amp;quot;world&amp;quot; という関数（オブジェクト）を登録
obj.func = function() {
  console.log(&amp;quot;world&amp;quot;;)
}

// ドット演算子
console.log(obj.hoge); // &amp;quot;hello&amp;quot;
obj.func(); // &amp;quot;world&amp;quot;

// 連想配列風にもアクセス可能
console.log(obj[&amp;quot;hoge&amp;quot;]); // &amp;quot;hello&amp;quot;
obj.[&amp;quot;func&amp;quot;](); // &amp;quot;world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;valueが関数の場合は&lt;code&gt;メソッド&lt;/code&gt;と呼び、それ以外のオブジェクトの場合は&lt;code&gt;プロパティ&lt;/code&gt;と呼ぶ。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配列もオブジェクトだけど、特別なプロパティ・メソッドが存在している（&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array&#34;&gt;必要な時にggる&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ちなみにオブジェクトはオブジェクトリテラルで作成する事も可能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;{}&lt;/code&gt;は&lt;code&gt;new Object()&lt;/code&gt;シンタックスシュガー（糖衣構文）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// new演算子でオブジェクトを作成した例
var obj = new Object();
obj.name = &amp;quot;Taro&amp;quot;;

// リテラルでオブジェクトを作成した場合
var obj = {name: &amp;quot;Taro&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;インスタンスとコンストラクタ&#34;&gt;インスタンスとコンストラクタ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタは関数オブジェクトで、インスタンスはコンストラクタを元に作成された空のオブジェクトの事。&lt;/li&gt;
&lt;li&gt;関数オブジェクト（コンストラクタ）を元に新しいオブジェクトを初期化して作成（インスタンス化）すると空のオブジェクト（インスタンス）ができる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takeharu/items/010752b1427773558f7c&#34;&gt;参考:JavaScriptのクラス？コンストラクタ？？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://uxmilk.jp/30348&#34;&gt;参考:JavaScriptのコンストラクタによるインスタンス生成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//空のコンストラクタを定義
var Animal = function(){};

//コンストラクタから空のインスタンスを生成
var dog = new Animal();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//コンストラクタを定義
function Animal = function(name,cry){
  this.name = name;
  this.bark = function() {
    console.log(cry);
  };
};

//コンストラクタから空のインスタンスを生成
var dog = new Animal(&#39;ポチ&#39;, &#39;ワン&#39;);
console.log(dog.name); // &amp;quot;ポチ&amp;quot;
dog.bark(); // ワン

var cat = new Animal(&#39;タマ&#39;,&#39;にゃー&#39;);
console.log(cat.name); // &amp;quot;タマ&amp;quot;
cat.bark(); // &amp;quot;にゃー&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;プロトタイプ&#34;&gt;プロトタイプ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタを定義すると、コンストラクタごとに関連付けられた&lt;strong&gt;「プロトタイプオブジェクト」&lt;/strong&gt;が暗黙的に作成される。&lt;/li&gt;
&lt;li&gt;同じコンストラクタから生成されたインスタンスは、プロトタイプオブジェクトを共有する。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.keicode.com/lang/prototypes.php&#34;&gt;参考:JavaScript入門 | プロトタイプとは？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/howdy39/items/35729490b024ca295d6c&#34;&gt;参考:図で理解するJavaScriptのプロトタイプチェーン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//コンストラクタを定義
function Animal = function(name){
  this.name = name;
};

var dog = new Animal(&#39;ポチ&#39;);
var cat = new Animal(&#39;タマ&#39;);

if (dog === cat) {
  // false
}

if (dog.prototype === cat.prototype) {
  // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;よく使われる謎コード&#34;&gt;よく使われる謎コード&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.f-sp.com/entry/2016/11/18/190732&#34;&gt;参考:JavaScriptの謎コードまとめ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!!x&lt;/code&gt; - 二重論理否定の意。二重論理否定には任意の型をBoolean型に変換する副作用がある。Boolean型のへの変更。よく使うらしい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x||0&lt;/code&gt; - 論理和の意。左辺値をBoolean型として評価して、trueなら左辺値。falseなら右辺値を評価値とする。左か右のどちらかがそのまま返ってくる。よく使うらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/05 - Thaad week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-thaad-week/</link>
      <pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-thaad-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;slackbot&#34;, &#34;MD5&#34;, &#34;SHA256&#34;, &#34;Atomic Design&#34;, &#34;Linuxコマンド&#34;,&#34;Storybook&#34;, &#34;npx&#34;, &#34;webpack&#34; &#34;require&#34;] --&gt;

&lt;h2 id=&#34;2018-05-21-learned&#34;&gt;2018/05/21 - Learned&lt;/h2&gt;

&lt;p&gt;5月21日（月）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;slackbotについて&#34;&gt;SlackBotについて&lt;/h3&gt;

&lt;p&gt;SlackBotを作る際に利用するSlack API Tokenには種類がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Slackのほぼすべての機能を使えるレガシートークン

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ykhirao/items/0d6b9f4a0cc626884dbb&#34;&gt;Slack APIのTokenの取得・場所&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;流出した場合は、チャンネルの削除から何からやり放題。必要な機能にしかアクセス権を与えないトークン&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ykhirao/items/3b19ee6a1458cfb4ba21&#34;&gt;Slack API 推奨Tokenについて - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;流出しても必要最低限の権限しか与えられていない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗号化について&#34;&gt;暗号化について&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MD5よりSHA256のほうが安全らしい

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/t-mochizuki/items/5ab21b6ae9b1941122ab&#34;&gt;md5とsha256を使ってみた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-22-learned&#34;&gt;2018/05/22 - Learned&lt;/h2&gt;

&lt;p&gt;5月22日（火）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;atomic-designについて&#34;&gt;Atomic Designについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;パーツ・コンポーネント単位で定義していく UI デザイン手法。&lt;/li&gt;
&lt;li&gt;アプローチ / 考え方

&lt;ul&gt;
&lt;li&gt;エディトリアル / グラフィックからではなく、マークアップ / コーディングからUI設計を行っていく手法で、メリットとしてUIが一定の品質でテンプレ化される事によって、非デザイナーでも一定水準の品質のプロダクトデザインを担保する事が可能。&lt;/li&gt;
&lt;li&gt;参考 : &lt;a href=&#34;http://design.dena.com/design/atomic-design-%E3%82%92%E5%88%86%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%A4%E3%82%82%E3%82%8A%E3%81%AB%E3%81%AA%E3%82%8B/&#34;&gt;Atomic Design を 分かったつもりになる&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# 構成要素
- atoms / 原子（あとむす）
  - UI部品の最小単位
- molecules / 分子（もれきゅーる）
  - 機能的なまとまり
- organisms / 生体（おーがにずむす）
  - ページ内のセクション
- templates / テンプレート（てんぷれーと）
  - ワイヤーフレームとなるもの
- pages / ページ
  - テンプレートに内容を入れた、実際表示される状態
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;考え方としてはBootstrapに近い。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-23-learned&#34;&gt;2018/05/23 - Learned&lt;/h2&gt;

&lt;p&gt;5月23日（水）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;next-jsについて&#34;&gt;Next.jsについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;とても楽に React の web application を開発する事が可能。

&lt;ul&gt;
&lt;li&gt;ReactをSSR（Server Side Rendering）し、Babelで書くことが出来、buildもしてくれつつ、Universal JavaScript Web Applicationを作成する事ができるOSSのWeb Framework。&lt;/li&gt;
&lt;li&gt;Reactの学習をした後、Next.jsを使えばShadow DOMの修学は問題ない&lt;/li&gt;
&lt;li&gt;仕様が明確で拡張性も高い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-24-learned&#34;&gt;2018/05/24 - Learned&lt;/h2&gt;

&lt;p&gt;5月24日（木）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;金沢の最高気温は19/7度、最低気温は16.7度。&lt;/li&gt;
&lt;li&gt;体調不良にてしんでおりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-25-learned&#34;&gt;2018/05/25 - Learned&lt;/h2&gt;

&lt;p&gt;5月25日（金）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.5hほどもくもくする時間を確保。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linuxコマンドについて&#34;&gt;Linuxコマンドについて&lt;/h3&gt;

&lt;h4 id=&#34;mkdir&#34;&gt;mkdir&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir hoge fuga&lt;/code&gt; で 複数ディレクトリを同時作成する事が可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir -p hoge/fuga piyo/foo&lt;/code&gt; で多階層ディレクトリを作成する事が可能&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;touch&#34;&gt;touch&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touch&lt;/code&gt; コマンド自体は指定したファイルのタイムスタンプを変更するコマンド。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch -t [[CC]YY]MMDDhhmm[.ss]&lt;/code&gt; で指定したタイムスタンプに変更できる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch hoge&lt;/code&gt; でファイルが存在していない場合は0サイズのファイルを作成する事ができる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pdcopy&#34;&gt;pdcopy&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pdcoby&lt;/code&gt; で、ターミナルの出力をクリップボードにコピーしてくれる

&lt;ul&gt;
&lt;li&gt;入力を終える場合は&lt;code&gt;Ctrl +D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub | pbcopy&lt;/code&gt; とかで利用すると便利。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;storybookについて&#34;&gt;Storybookについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;React / Raact Native / Vue向けのUI開発環境。&lt;/li&gt;
&lt;li&gt;サンドボックス環境を構築してコンポーネントの挙動やコンポーネントを一望できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使いみち&#34;&gt;使いみち&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;自作コンポーネントのライブラリー（一覧）や状態込みのスタイルガイド&lt;/li&gt;
&lt;li&gt;ページの作成中、適切なコンポーネントを素早く選び出す&lt;/li&gt;
&lt;li&gt;開発中・開発後にコンポーネントの UI をテストする&lt;/li&gt;
&lt;li&gt;コンポーネントや API のドキュメント&lt;/li&gt;
&lt;li&gt;エンジニアやデザイナー間のコミュニケーション&lt;/li&gt;
&lt;li&gt;アプリケーションの仕様書&lt;/li&gt;
&lt;li&gt;参考 : &lt;a href=&#34;https://storybook.js.org/examples/&#34;&gt;https://storybook.js.org/examples/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;npxについて&#34;&gt;npxについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsを8.2.0以上にアップデートすると利用する事が可能。&lt;/li&gt;
&lt;li&gt;できる事

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm i&lt;/code&gt; で インストールしたパッケージを &lt;code&gt;npx {パッケージ名}&lt;/code&gt; で実行する事が可能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;これまでの実行方法

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;./node_modules/.bin/(パッケージ名)&lt;/code&gt; で実行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(npm bin)/(パッケージ名)&lt;/code&gt; で実行&lt;/li&gt;
&lt;li&gt;package.jsonにnpm-scriptを記述して実行&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;おまけ

&lt;ul&gt;
&lt;li&gt;ローカルにインストールしていないパッケージを&lt;code&gt;npx {パッケージ名}&lt;/code&gt; で実行する事が可能（↓こんなかんじ）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ npx cowsay nyarnしか書けねえ体にしてやろうか！

npx: 10個のパッケージを2.106秒でインストールしました。
 _____________________________________
&amp;lt; nyarnしか書けねえ体にしてやろうか！ &amp;gt;
 -------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;webpackについて&#34;&gt;Webpackについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モジュールバンドラーとは、モジュールをひとまとめにするツールであり、JSのモジュール各種をまとめて依存関係を解決してひとつのファイルにしてくれるツール。&lt;/li&gt;
&lt;li&gt;もともとはNode.jsの&lt;code&gt;require()&lt;/code&gt;というモジュール読み込みの仕組み。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;entry&#34;&gt;Entry&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;読み込みを行うモジュールの 依存関係を解決する為のエントリポイント&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;output&#34;&gt;Output&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;バンドルされたファイルのアウトプット先。&lt;/li&gt;
&lt;li&gt;出力先は絶対パスじゃないとだめ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;requireの歴史&#34;&gt;requireの歴史&lt;/h3&gt;

&lt;h4 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JS便利だからブラウザ以外でも使おうぜ。サーバサイドとか。&lt;/li&gt;
&lt;li&gt;でもブラウザ上で動かす為のものだから動かないよね。&lt;/li&gt;
&lt;li&gt;困るから、ServerSideの標準仕様を定めようぜ → commonJS&lt;/li&gt;
&lt;li&gt;外部ライブラリの参照は各JSをモジュール化して、&lt;code&gt;require()&lt;/code&gt;で読み込みしよう → commonJSの仕様として出てきた。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;node-js&#34;&gt;Node.js&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;サーバサイドでJSを利用できるようにしたもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require()&lt;/code&gt; は独自拡張されたらしい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt; したパッケージは &lt;code&gt;require()&lt;/code&gt; で読み込む事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;requirejs&#34;&gt;RequireJS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;クライアントサイドでも&lt;code&gt;reauire()&lt;/code&gt;を使う為に作られたライブラリ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;webpack&#34;&gt;WebPack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;RequireJSをもっと強くしたもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reauire()&lt;/code&gt; の対象範囲をJSのモジュールだけではなく、

&lt;ul&gt;
&lt;li&gt;altJSのコンパイル&lt;/li&gt;
&lt;li&gt;CSS / HTMLファイル取り込み&lt;/li&gt;
&lt;li&gt;JSファイルの取り込み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考  : &lt;a href=&#34;https://qiita.com/uryyyyyyy/items/b10b012703b5396ded5a&#34;&gt;require()とは何か？何が便利なのか - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/05 - Second week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-second-week/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-second-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!--tags = [ “git”, “submodule”, “CLI”, ”npx”, “名刺”, “回線速度” ]--&gt;

&lt;h2 id=&#34;2018-05-14-learned&#34;&gt;2018/05/14 - Learned&lt;/h2&gt;

&lt;p&gt;5月14日（月）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;gitについて&#34;&gt;Gitについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git push origin HEAD&lt;/code&gt; で、pushした場合は毎回、現在のCurrent branch　でpushする事ができる。

&lt;ul&gt;
&lt;li&gt;毎回、&lt;code&gt;git push origin feature/HOGEHOGE/FUGAFUGA-1001&lt;/code&gt; みたいなの入力してたのでかなり楽になって良い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gitconfigで指定されているuser.name等がgitに記録されるタイミングは &lt;code&gt;git commit&lt;/code&gt;をしたタイミング。

&lt;ul&gt;
&lt;li&gt;違うユーザアカウントでpushしてしまった為、gittconfigを書き換えて治そうとしたが、再度commitしないと治らなかった為、判明。&lt;/li&gt;
&lt;li&gt;個人のuser.nameで業務リポジトリにpushされてちょっと恥ずかしかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-15-learned&#34;&gt;2018/05/15 - Learned&lt;/h2&gt;

&lt;p&gt;5月15（火）日のToday I Leaned。&lt;/p&gt;

&lt;h3 id=&#34;gitについて-1&#34;&gt;Gitについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ブログのテーマがsubmodule化されているが、毎回読み込みの仕方を忘れる

&lt;ul&gt;
&lt;li&gt;gitのsubmoduleは、メインのリポジトリで&lt;code&gt;git submodule update -i&lt;/code&gt;とすると、submoduleの取り込みを行う。&lt;/li&gt;
&lt;li&gt;git submodule foreach git pull origin master` で最新のsubmodule側のリポジトリの状態に更新してくれる&lt;/li&gt;
&lt;li&gt;尚、上記コマンドを入力する所は、メインのリポジトリのrootで大゛勝負な模様。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-16-learnded&#34;&gt;2018/05/16 - Learnded&lt;/h2&gt;

&lt;p&gt;5月16（水）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;回線速度調査の手法&#34;&gt;回線速度調査の手法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CLIから回線速度のテストが出来るようにするfast-cliというものがあるらしい。

&lt;ul&gt;
&lt;li&gt;Nodeで動くので &lt;code&gt;npm install --global fast-cli&lt;/code&gt;でインストールしたら、fastコマンドで動作するようになる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/suin/items/8398f0b07299a3cc194f&#34;&gt;参考 : 回線速度のテストができる「fast」コマンドが便利だった - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CLIでnpxを活用して自己紹介をする方法があった。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/akameco/items/e0af9e3cdf1cdb6fca61&#34;&gt;名刺の代わりにCLIアプリを書く - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-17-learnded&#34;&gt;2018/05/17 - Learnded&lt;/h2&gt;

&lt;p&gt;5月17（木）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;知識メモ&#34;&gt;知識メモ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ハインリッヒの法則というものがある。

&lt;ul&gt;
&lt;li&gt;内容としては、 1つの重大事故の背後には29の軽微な事故があり、その背景には300の異常が存在するというもの。&lt;/li&gt;
&lt;li&gt;つまり、重大な事故がX件ある場合は、29倍の軽微な事故・災害があって、300倍のヒヤリ・ハットがあるという事。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;セキュリティ対策&#34;&gt;セキュリティ対策&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;セキュリティ対策は重要だという話。

&lt;ul&gt;
&lt;li&gt;ハッカーは脆弱性の隙間を突いて、最終的にサーバのrootをハッキングする為の行動を取る。&lt;/li&gt;
&lt;li&gt;Ubuntu + Drupal構成のサーバがあった場合は、&lt;/li&gt;
&lt;li&gt;利用しているポートを確認。&lt;/li&gt;
&lt;li&gt;Drupalのバージョン確認 → 脆弱性を確認してアタック&lt;/li&gt;
&lt;li&gt;Drupalのアカウントを作成&lt;/li&gt;
&lt;li&gt;Drupal上でPHPを実行可能にするPluginを導入&lt;/li&gt;
&lt;li&gt;phpinfoでサーバ情報を取得 → サーバのバージョンを確認&lt;/li&gt;
&lt;li&gt;サーバの脆弱性をアタックしてrootユーザのパスワードを取得&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-18-learnded&#34;&gt;2018/05/18 - Learnded&lt;/h2&gt;

&lt;p&gt;5月18（木）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;ユーザテストについて&#34;&gt;ユーザテストについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ここ数日、某サービスのユーザテストの被験者として体験して思った事。&lt;/li&gt;
&lt;li&gt;サービス利用に至った背景や、テスト開始時点での状況説明を適切に行う必要がある。&lt;/li&gt;
&lt;li&gt;その説明を怠ると、そもそも把握している前提条件の元でテストを行っているつもりが、違う所で躓いてしまって求める問いと異なるテスト結果になりそうな為。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - ReactStudy#02</title>
      <link>https://kglabo.com/blog/react-study-02/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/react-study-02/</guid>
      <description>

&lt;h2 id=&#34;やった事&#34;&gt;やった事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create-react-app

&lt;ul&gt;
&lt;li&gt;テンプレ作成&lt;/li&gt;
&lt;li&gt;テンプレ編集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Babel

&lt;ul&gt;
&lt;li&gt;es2015からの変換(トランスパイル)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;必要なパッケージのインストール

&lt;ul&gt;
&lt;li&gt;babel-cli&lt;/li&gt;
&lt;li&gt;babel-preset-env&lt;/li&gt;
&lt;li&gt;babel-preset-react&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;わかった事&#34;&gt;わかった事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Babel使うとコードの記述がものすごい楽。&lt;/li&gt;
&lt;li&gt;JSX使わなくてもReactは書けるけど、クソ面倒くさいから使ったほうが楽。というか普通は使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;次にやること&#34;&gt;次にやること&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ReactでComponentを作成する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;備考&#34;&gt;備考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;babel-preset-env&lt;/code&gt;がECMAScriptのサポート環境に応じたプラグインを設定するプリセットパッケージ。という説明だったがあんまりピンと来てないのでそのうち調べる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;リポジトリ&#34;&gt;リポジトリ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yu-kgr/learn-react-app&#34;&gt;yu-kgr/learn-react-app&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yu-kgr/learn-react-app/commit/eb59019dd89bae478e4db7494b6adff278ec66f2&#34;&gt;該当コミットログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - JavaScript - DOMオブジェクトについて</title>
      <link>https://kglabo.com/blog/javascript-study-01/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/javascript-study-01/</guid>
      <description>

&lt;h2 id=&#34;javascript-domオブジェクトについて&#34;&gt;JavaScript - DOMオブジェクトについて&lt;/h2&gt;

&lt;p&gt;JavaScriptでWebサイトを動的に書き換えるには、Document Object Model（DOM）という仕組みを利用する&lt;/p&gt;

&lt;h2 id=&#34;document-object-model-dom-とは&#34;&gt;Document Object Model（DOM）とは&lt;/h2&gt;

&lt;p&gt;JavaScriptで記述されたプログラムから、HTMLページにアクセスして、HTMLページを操作する方法を提供している。&lt;/p&gt;

&lt;h2 id=&#34;domツリー&#34;&gt;DOMツリー&lt;/h2&gt;

&lt;p&gt;DOMツリーとは、HTMLドキュメントやXMLドキュメントをツリー構造として表現したもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;大見出し&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;中見出し&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;DOMツリーとは、HTMLドキュメントやXMLドキュメントを&amp;lt;strong&amp;gt;ツリー構造&amp;lt;/strong&amp;gt;として表現したもの。&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Document

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; - Document&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - 見出し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; - 見出し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; - DOMツリーとは、HTMLドキュメントやXMLドキュメントをツリー構造として表現したもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; - ツリー構造&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ノード&#34;&gt;ノード&lt;/h2&gt;

&lt;p&gt;文章を構成する要素、属性、テキストといったオブジェクトをノードと呼ぶ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要素ノード&lt;/li&gt;
&lt;li&gt;属性ノード&lt;/li&gt;
&lt;li&gt;テキストノード&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dom仕様策定について&#34;&gt;DOM仕様策定について&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DOMの仕様は、Level1~4がW3Cにより策定。

&lt;ul&gt;
&lt;li&gt;W3Cとは、WEBで使用される各種技術の標準化を推進する為に設立された団体。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最新版は、WHATWG（Web Hypertext Application Technology Working Group）というコミュニティーがLiving Standardとして定義。

&lt;ul&gt;
&lt;li&gt;Living Standardとは常に改良が加えられているゆるい規格のようなもの。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ブラウザオブジェクトの階層構造&#34;&gt;ブラウザオブジェクトの階層構造&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;window

&lt;ul&gt;
&lt;li&gt;screen&lt;/li&gt;
&lt;li&gt;document&lt;/li&gt;
&lt;li&gt;location&lt;/li&gt;
&lt;li&gt;form

&lt;ul&gt;
&lt;li&gt;Element&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;anchor&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;navigator&lt;/li&gt;
&lt;li&gt;history&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;window-オブジェクト&#34;&gt;window オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザを操作するための機能を集めたオブジェクト&lt;/li&gt;
&lt;li&gt;ブラウザオブジェクトの階層構造の最上位に位置する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;document-オブジェクト&#34;&gt;document オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windowオブジェクト内に表示された、HTMLで表現されているコンテンツを保持しているオブジェクト&lt;/li&gt;
&lt;li&gt;Window内に表示されたドキュメントを操作するのは、Documentオブジェクトの役割。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;location-オブジェクト&#34;&gt;Location オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;現在表示されているページのロケーションに関する情報を提供する&lt;/li&gt;
&lt;li&gt;現在の表示URLアドレスに関する情報を取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;history-オブジェクト&#34;&gt;history オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザの履歴の操作&lt;/li&gt;
&lt;li&gt;画面上に表示しているページの移動などの操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;navigator-オブジェクト&#34;&gt;Navigator オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザ名やバージョンなど、ブラウザ固有の情報を提供する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;screen-オブジェクト&#34;&gt;screen オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ディスプレイに関する情報を提供する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;form-オブジェクト&#34;&gt;form オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Formに関する情報を提供&lt;/li&gt;
&lt;li&gt;Formの操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;anchor-オブジェクト&#34;&gt;Anchor オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ページ上のアンカー（&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;）に関する情報を取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;images-オブジェクト&#34;&gt;Images オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;画像に関する情報の提供&lt;/li&gt;
&lt;li&gt;画像を操作する機能の提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;elements-オブジェクト&#34;&gt;Elements オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTMLドキュメントやXMLドキュメントにおける、要素（タグ）の事&lt;/li&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;hogefuga&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TIL - UX研修 - 他社UI調査/インタビュー設計</title>
      <link>https://kglabo.com/blog/til-user-experience-training-02/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-user-experience-training-02/</guid>
      <description>

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ&lt;/h2&gt;

&lt;p&gt;社内でのUX研修で学んだ事のメモ&lt;/p&gt;

&lt;h2 id=&#34;研修内容&#34;&gt;研修内容&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;他社UI調査&lt;/li&gt;
&lt;li&gt;インタビュー設計&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;問いを立てる&#34;&gt;問いを立てる&lt;/h2&gt;

&lt;p&gt;実際に競合他社と比較して問いを立てる（20分）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;こうだと思うけど（仮説）&lt;/li&gt;
&lt;li&gt;こうなっているのは（現実）&lt;/li&gt;
&lt;li&gt;なぜだろう（問い）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;仮説ではなく問いを立てる&#34;&gt;仮説ではなく問いを立てる&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;仮説では質問者の考え（バイアス）が掛かるため、純粋に知りたい問いを探す&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;定量調査と定性調査&#34;&gt;定量調査と定性調査&lt;/h2&gt;

&lt;h3 id=&#34;定量調査&#34;&gt;定量調査&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ログ重視/結果重視&lt;/li&gt;
&lt;li&gt;広く浅い情報を取り扱う&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;定性調査&#34;&gt;定性調査&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ログ化されていない情報の収集&lt;/li&gt;
&lt;li&gt;新しい価値の発見/狭く深い情報を取り扱う&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;定量調査と定性調査の組み合わせが大事&#34;&gt;定量調査と定性調査の組み合わせが大事&lt;/h4&gt;

&lt;p&gt;現状何が起きているのかを定量調査で確認して、&lt;br /&gt;
定性調査でどうしてそうなっているのかプロセスを確認して行って施策の成果を定量調査で確認する。&lt;/p&gt;

&lt;h4 id=&#34;定性調査の種類&#34;&gt;定性調査の種類&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;エスノグラフィ

&lt;ul&gt;
&lt;li&gt;被験者の実際の利用現場に赴きも場合によっては調査者自身も被験者と一体となり調査する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンテクスチュアルインクワイアリー

&lt;ul&gt;
&lt;li&gt;被験者が自分の行動や思いを説明しながら、サービスやプロダクトを普段通りに利用してもらう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;オブザベーション

&lt;ul&gt;
&lt;li&gt;調査側が用意した手順に沿ってサービスやプロダクトを利用してもらい、観察をする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;インタビュー

&lt;ul&gt;
&lt;li&gt;双方向のやり取りを交えて、被験者に話を聞く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;アンケート

&lt;ul&gt;
&lt;li&gt;一方的に示した問に対して、情報を収集する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;インタビューの種類&#34;&gt;インタビューの種類&lt;/h4&gt;

&lt;p&gt;今回はインタビューについて深掘り・学習する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に設問を決めずに、その場に合わせて質問する。予想だにしてなかった発見があるが、時間がかかる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;半構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に決めた設問に沿って進めつつ、必要な箇所は深掘りをしていく。時間的に効率よく進められ深掘りもできるが、バイアスがかかる懸念。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に決めておいた設問のみ質問する。短時間で終わるが深掘りができない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;インタビュー設計&#34;&gt;インタビュー設計&lt;/h2&gt;

&lt;p&gt;インタビューをどうやって行うかの設計。&lt;/p&gt;

&lt;h2 id=&#34;調査の目的を明らかにする&#34;&gt;調査の目的を明らかにする&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;調査で、何を明らかにしたいのかを決める&lt;/li&gt;
&lt;li&gt;調査結果を何に、どのように使うのかを決める&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;被験者集め-リクルーティング&#34;&gt;被験者集め（リクルーティング）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被験者の条件を決定&lt;/li&gt;
&lt;li&gt;話を聞くべき人の条件を洗い出す ※複数のセグメントを設定することもできる&lt;/li&gt;
&lt;li&gt;被験者の数を決定

&lt;ul&gt;
&lt;li&gt;最低でも３人、一般的には５人&lt;/li&gt;
&lt;li&gt;※ただしセグメントごとにこの人数が必要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被験者候補の抽出

&lt;ul&gt;
&lt;li&gt;人づて（知り合い、知り合いの知り合い）&lt;/li&gt;
&lt;li&gt;スクリーニングアンケート&lt;/li&gt;
&lt;li&gt;外部の調査会社に依頼&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;実査の調整

&lt;ul&gt;
&lt;li&gt;セグメントと照合しているか直接確認&lt;/li&gt;
&lt;li&gt;日程調整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インタビュー設計-1&#34;&gt;インタビュー設計&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ラポールの形成

&lt;ul&gt;
&lt;li&gt;リラックスしてもらい、本音を言いやすい空気を作る ※挨拶の応答や雑談で会話をし、被験者にも声を出してもらう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;インフォームドコンセント

&lt;ul&gt;
&lt;li&gt;安心して意見を言えるように、調査について伝える ※調査目的、個人情報の取り扱い、任意参加である点などを伝える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基本情報の質問

&lt;ul&gt;
&lt;li&gt;本題に入る前に、周辺状況や利用の背景について質問する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本題の質問&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;本題の質問&#34;&gt;本題の質問&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;インタビュー内容の設計手順

&lt;ul&gt;
&lt;li&gt;知りたいことを答えてもらえる質問にする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;明らかにしたいことを洗い出す&lt;/li&gt;
&lt;li&gt;明らかにしたいことを精査し優先度をつけ、高いものをピックアップする&lt;/li&gt;
&lt;li&gt;明らかにしたいことを知るために、何をどのように聞くべきかを検討する&lt;/li&gt;
&lt;li&gt;設問を並べ、答えが得られやすいような順番を検討する&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;インタビュー内容の設計tips&#34;&gt;インタビュー内容の設計TIPS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被験者が「はい / いいえ」で答えられない、回答が膨らむような質問にしましょう

&lt;ul&gt;
&lt;li&gt;はい、いいえで終わるとそれ以上の情報が得られません。被験者が自ら説明してくれるような質問が理想です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被験者が利用する状況や背景、理由などが明らかになる質問をしましょう

&lt;ul&gt;
&lt;li&gt;被験者の行為や結果だけではなく、なぜその結果に至ったのかという点が最も重要です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;答えやすい質問を先に、答えにくい質問を後に回しましょう

&lt;ul&gt;
&lt;li&gt;被験者が話しやすい順序を工夫しましょう。場合によっては用意した順序を入れ替えてもかまいません。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;質問者の思い込みが入り、被験者の答えが偏るような質問はやめましょう

&lt;ul&gt;
&lt;li&gt;自分が持っている仮説を検証するような質問ではなく、被験者のありのままの情報を収集すると理解が深まります。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;情報が引き出せない場合、初めての利用や直近の利用を質問してみましょう

&lt;ul&gt;
&lt;li&gt;初めての利用や直近の利用は記憶に残りやすいです。足がかりとして被験者の情報を引き出すことができます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;インタビュー項目の設計&#34;&gt;インタビュー項目の設計&lt;/h2&gt;

&lt;p&gt;インタビュー項目の設計を実際に行う（20分）&lt;br /&gt;
設計する際の順番は、先に作成した問いに対して下記の事を意識して作成する。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;優先度をつける&lt;/li&gt;
&lt;li&gt;何をどのように聞くべきか検討する&lt;/li&gt;
&lt;li&gt;答えが得られやすいような順番を検討する&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;10分程度のインタビューだと適正数は3~4つの問い&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - エンジニアの稼働率と工数管理について</title>
      <link>https://kglabo.com/blog/til-man-hour-managa/</link>
      <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-man-hour-managa/</guid>
      <description>

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ&lt;/h2&gt;

&lt;p&gt;主にウォーターフォール時に各タスクの工数を算出したり作業分解したタスクをどう割り振るのか考える時に役に立つであろう情報。&lt;/p&gt;

&lt;h2 id=&#34;稼働率&#34;&gt;稼働率&lt;/h2&gt;

&lt;p&gt;稼働率 is 働ける割合。&lt;/p&gt;

&lt;p&gt;稼働率は、1日あたり8時間となるので、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;8h ＝ 480min ＝ 100%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;60min = 12.5%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;て、1hにつき &lt;code&gt;12.5%&lt;/code&gt; となる。&lt;/p&gt;

&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;

&lt;p&gt;5時間掛かる作業の場合は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;12.5*5 = 62.5%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを「何日かけて対応するか」で日数分で割る。&lt;br /&gt;
「何日かけて対応するか」はメンバーの空き稼働率の状況で判断する。&lt;/p&gt;

&lt;h2 id=&#34;役割毎の稼働率の違い&#34;&gt;役割毎の稼働率の違い&lt;/h2&gt;

&lt;p&gt;末端作業者と管理層では一日の作業に費やすことができる稼働率が異なる。&lt;br /&gt;
一般的には末端作業者は &lt;code&gt;70~80%&lt;/code&gt; が限度。&lt;/p&gt;

&lt;p&gt;例えば、会議や雑務の割合が多くて、&lt;br /&gt;
1日あたり4hは管理系業務で時間が取られている場合は、&lt;/p&gt;

&lt;p&gt;8hのうち、4hしか作業時間を確保できない為、&lt;br /&gt;
&lt;code&gt;8h - 4h = 4h&lt;/code&gt; で、作業割合 &lt;code&gt;50%（12.5 ✕ 4）&lt;/code&gt; が上限となる。&lt;/p&gt;

&lt;p&gt;管理者は自分自身の稼働率がどの程度なのか確認しておくと良い。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;期間と作業割合がわかっているタスクに関しては、&lt;br /&gt;
逆算して初期見積入れておいても良い。
※ 単純にタスクに何時間かけるか分かるようになるだけだが‥&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>